/******************************************************************************/
/* Configuration pour l'archivage des différents éléments du fichier source   */
/******************************************************************************/
// !CONFIG!=/L/* /R/* /W"* Nom : "
// Définition du système       !CONFIG!=/V1!EMULATEUR CPC!
// Définition du sous système  !CONFIG!=/V2!PC-CPC!
// Définition du sous ensemble !CONFIG!=/V3!Chips!
// Définition du module        !CONFIG!=/V4!CPU Z80!
/******************************************************************************/

/********************************************************* !NAME! **************
 * !./FLE!
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\Fichiers
 ********************************************************** !0! *****************
 * ------------------------------------------------------------------------------
 *          SYSTEME         |      SOUS SYSTEME       |      SOUS ENSEMBLE
 * ------------------------------------------------------------------------------
 *  EMULATEUR CPC           | PC-CPC                  | Chips
 * ------------------------------------------------------------------------------
 *  Fichier     : Z80.C                 | Version : 0.1am
 * ------------------------------------------------------------------------------
 *  Date        : 05/11/2002            | Auteur  : L.DEPLANQUE
 * ------------------------------------------------------------------------------
 *  Description : Emulation des instructions du Z80
 *
 * ------------------------------------------------------------------------------
 *  Historique  :
 *           Date           |         Auteur          |       Description
 * ------------------------------------------------------------------------------
 *  05/11/2002              | L.DEPLANQUE             | creation
 * ------------------------------------------------------------------------------
 *  13/11/2002              | L.DEPLANQUE             | Optimisation PEEK16() et
 *                          |                         | POKE16(), ajout #defines
 *                          |                         | USE_16_BIT, FAST_16_BIT.
 *                          |                         | Optimisation LDIR et LDDR
 * ------------------------------------------------------------------------------
 *  14/11/2002              | L.DEPLANQUE             | Optimisation CPIR et CPDR
 * ------------------------------------------------------------------------------
 *  20/02/2003              | L.DEPLANQUE             | Version 0.1w :
 *                          |                         | Optimisation PEEK et POKE
 *                          |                         | Dépendant de VC++
 * ------------------------------------------------------------------------------
 *  21/01/2004              | L.DEPLANQUE             | Version 0.1x :
 *                          |                         | Gestion nouvelles
 *                          |                         | routines disc
 * ------------------------------------------------------------------------------
 *  30/03/2004              | L.DEPLANQUE             | Version 0.1z :
 *                          |                         | Optimisations fonctions
 *                          |                         | émulation Z80 : retour
 *                          |                         | du nombre de cycles
 *                          |                         | plutôt que incrément
 *                          |                         | variable globale
 * ------------------------------------------------------------------------------
 *  21/04/2004              | L.DEPLANQUE             | Version 0.1aa :
 *                          |                         | Correction des temps de
 *                          |                         | cycle des instructions
 *                          |                         | après préfixe DD et FD
 *                          |                         | (sur registres IX et IY)
 *                          |                         | Suppression du #define
 *                          |                         | USE_16_BIT, car toujours
 *                          |                         | utilisé maintenant.
 * ------------------------------------------------------------------------------
 *  06/08/2004              | L.DEPLANQUE             | Version 0.1ab :
 *                          |                         | Ajout des instructions
 *                          |                         | NEG aux OPCODES ED_4C,
 *                          |                         | ED_54, ED_5C, ED_64,
 *                          |                         | ED_6C, ED_74, ED_7C
 * ------------------------------------------------------------------------------
 *  11/12/2004              | L.DEPLANQUE             | Version 0.1ae :
 *                          |                         | Ajout des instructions
 *                          |                         | ED_01 a ED_07 pour
 *                          |                         | gestion rom extension
 *                          |                         | compactage/décompactage
 * ------------------------------------------------------------------------------
 *  27/11/2005              | L.DEPLANQUE             | Version 0.1ah :
 *                          |                         | Ajout instruction ED_08
 *                          |                         | (pour rompack)
 * ------------------------------------------------------------------------------
 *  18/12/2005              | L.DEPLANQUE             | Version 0.1aj :
 *                          |                         | Ajout instruction ED_09
 *                          |                         | (pour rompack)
 * ------------------------------------------------------------------------------
 *  16/02/2006              | L.DEPLANQUE             | Version 0.1ak :
 *                          |                         | Ajout instruction ED_0A
 *                          |                         | (pour rompack)
 * ------------------------------------------------------------------------------
 *  20/07/2006              | L.DEPLANQUE             | Version 0.1al :
 *                          |                         | Ajout instruction ED_0B
 *                          |                         | a ED_16 (pour rompack),
 *                          |                         | ajout instructions DD_FD
 *                          |                         | et FD_DD
 * ------------------------------------------------------------------------------
 *  05/09/2006              | L.DEPLANQUE             | Version 0.1am :
 *                          |                         | Ajout instruction ED_17
 *                          |                         | a ED_1A (pour rompack),
 *                          |                         | Correction timings
 *                          |                         | instructions.
 * ------------------------------------------------------------------------------
 ********************************************************** !END! **************/

#include  "z80.h"

#include  <stdio.h>

#include  "vga.h"
#include  "crtc.h"
#include  "gestport.h"
#include  "config.h"
#include  "plateform.h"
#include  "rompack.h"


#define MASK_14BIT      0x3FFF



void VerifyIRQ(core_crocods_t *core);


extern pfct tabCB[ 256 ];
extern pfct tabED[ 256 ];
extern pfct tabIX[ 256 ];
extern pfct tabIY[ 256 ];


/********************************************************* !NAME! **************
 * Nom : TabDAA
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Variables Globales
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Utilisé pour émuler l'instruction DAA
 *
 ********************************************************** !0! ****************/
static USHORT TabDAA[ 2048 ] =
{
    0x0044, 0x0100, 0x0200, 0x0304, 0x0400, 0x0504, 0x0604, 0x0700,
    0x0808, 0x090C, 0x1010, 0x1114, 0x1214, 0x1310, 0x1414, 0x1510,
    0x1000, 0x1104, 0x1204, 0x1300, 0x1404, 0x1500, 0x1600, 0x1704,
    0x180C, 0x1908, 0x2030, 0x2134, 0x2234, 0x2330, 0x2434, 0x2530,
    0x2020, 0x2124, 0x2224, 0x2320, 0x2424, 0x2520, 0x2620, 0x2724,
    0x282C, 0x2928, 0x3034, 0x3130, 0x3230, 0x3334, 0x3430, 0x3534,
    0x3024, 0x3120, 0x3220, 0x3324, 0x3420, 0x3524, 0x3624, 0x3720,
    0x3828, 0x392C, 0x4010, 0x4114, 0x4214, 0x4310, 0x4414, 0x4510,
    0x4000, 0x4104, 0x4204, 0x4300, 0x4404, 0x4500, 0x4600, 0x4704,
    0x480C, 0x4908, 0x5014, 0x5110, 0x5210, 0x5314, 0x5410, 0x5514,
    0x5004, 0x5100, 0x5200, 0x5304, 0x5400, 0x5504, 0x5604, 0x5700,
    0x5808, 0x590C, 0x6034, 0x6130, 0x6230, 0x6334, 0x6430, 0x6534,
    0x6024, 0x6120, 0x6220, 0x6324, 0x6420, 0x6524, 0x6624, 0x6720,
    0x6828, 0x692C, 0x7030, 0x7134, 0x7234, 0x7330, 0x7434, 0x7530,
    0x7020, 0x7124, 0x7224, 0x7320, 0x7424, 0x7520, 0x7620, 0x7724,
    0x782C, 0x7928, 0x8090, 0x8194, 0x8294, 0x8390, 0x8494, 0x8590,
    0x8080, 0x8184, 0x8284, 0x8380, 0x8484, 0x8580, 0x8680, 0x8784,
    0x888C, 0x8988, 0x9094, 0x9190, 0x9290, 0x9394, 0x9490, 0x9594,
    0x9084, 0x9180, 0x9280, 0x9384, 0x9480, 0x9584, 0x9684, 0x9780,
    0x9888, 0x998C, 0x0055, 0x0111, 0x0211, 0x0315, 0x0411, 0x0515,
    0x0045, 0x0101, 0x0201, 0x0305, 0x0401, 0x0505, 0x0605, 0x0701,
    0x0809, 0x090D, 0x1011, 0x1115, 0x1215, 0x1311, 0x1415, 0x1511,
    0x1001, 0x1105, 0x1205, 0x1301, 0x1405, 0x1501, 0x1601, 0x1705,
    0x180D, 0x1909, 0x2031, 0x2135, 0x2235, 0x2331, 0x2435, 0x2531,
    0x2021, 0x2125, 0x2225, 0x2321, 0x2425, 0x2521, 0x2621, 0x2725,
    0x282D, 0x2929, 0x3035, 0x3131, 0x3231, 0x3335, 0x3431, 0x3535,
    0x3025, 0x3121, 0x3221, 0x3325, 0x3421, 0x3525, 0x3625, 0x3721,
    0x3829, 0x392D, 0x4011, 0x4115, 0x4215, 0x4311, 0x4415, 0x4511,
    0x4001, 0x4105, 0x4205, 0x4301, 0x4405, 0x4501, 0x4601, 0x4705,
    0x480D, 0x4909, 0x5015, 0x5111, 0x5211, 0x5315, 0x5411, 0x5515,
    0x5005, 0x5101, 0x5201, 0x5305, 0x5401, 0x5505, 0x5605, 0x5701,
    0x5809, 0x590D, 0x6035, 0x6131, 0x6231, 0x6335, 0x6431, 0x6535,
    0x6025, 0x6121, 0x6221, 0x6325, 0x6421, 0x6525, 0x6625, 0x6721,
    0x6829, 0x692D, 0x7031, 0x7135, 0x7235, 0x7331, 0x7435, 0x7531,
    0x7021, 0x7125, 0x7225, 0x7321, 0x7425, 0x7521, 0x7621, 0x7725,
    0x782D, 0x7929, 0x8091, 0x8195, 0x8295, 0x8391, 0x8495, 0x8591,
    0x8081, 0x8185, 0x8285, 0x8381, 0x8485, 0x8581, 0x8681, 0x8785,
    0x888D, 0x8989, 0x9095, 0x9191, 0x9291, 0x9395, 0x9491, 0x9595,
    0x9085, 0x9181, 0x9281, 0x9385, 0x9481, 0x9585, 0x9685, 0x9781,
    0x9889, 0x998D, 0xA0B5, 0xA1B1, 0xA2B1, 0xA3B5, 0xA4B1, 0xA5B5,
    0xA0A5, 0xA1A1, 0xA2A1, 0xA3A5, 0xA4A1, 0xA5A5, 0xA6A5, 0xA7A1,
    0xA8A9, 0xA9AD, 0xB0B1, 0xB1B5, 0xB2B5, 0xB3B1, 0xB4B5, 0xB5B1,
    0xB0A1, 0xB1A5, 0xB2A5, 0xB3A1, 0xB4A5, 0xB5A1, 0xB6A1, 0xB7A5,
    0xB8AD, 0xB9A9, 0xC095, 0xC191, 0xC291, 0xC395, 0xC491, 0xC595,
    0xC085, 0xC181, 0xC281, 0xC385, 0xC481, 0xC585, 0xC685, 0xC781,
    0xC889, 0xC98D, 0xD091, 0xD195, 0xD295, 0xD391, 0xD495, 0xD591,
    0xD081, 0xD185, 0xD285, 0xD381, 0xD485, 0xD581, 0xD681, 0xD785,
    0xD88D, 0xD989, 0xE0B1, 0xE1B5, 0xE2B5, 0xE3B1, 0xE4B5, 0xE5B1,
    0xE0A1, 0xE1A5, 0xE2A5, 0xE3A1, 0xE4A5, 0xE5A1, 0xE6A1, 0xE7A5,
    0xE8AD, 0xE9A9, 0xF0B5, 0xF1B1, 0xF2B1, 0xF3B5, 0xF4B1, 0xF5B5,
    0xF0A5, 0xF1A1, 0xF2A1, 0xF3A5, 0xF4A1, 0xF5A5, 0xF6A5, 0xF7A1,
    0xF8A9, 0xF9AD, 0x0055, 0x0111, 0x0211, 0x0315, 0x0411, 0x0515,
    0x0045, 0x0101, 0x0201, 0x0305, 0x0401, 0x0505, 0x0605, 0x0701,
    0x0809, 0x090D, 0x1011, 0x1115, 0x1215, 0x1311, 0x1415, 0x1511,
    0x1001, 0x1105, 0x1205, 0x1301, 0x1405, 0x1501, 0x1601, 0x1705,
    0x180D, 0x1909, 0x2031, 0x2135, 0x2235, 0x2331, 0x2435, 0x2531,
    0x2021, 0x2125, 0x2225, 0x2321, 0x2425, 0x2521, 0x2621, 0x2725,
    0x282D, 0x2929, 0x3035, 0x3131, 0x3231, 0x3335, 0x3431, 0x3535,
    0x3025, 0x3121, 0x3221, 0x3325, 0x3421, 0x3525, 0x3625, 0x3721,
    0x3829, 0x392D, 0x4011, 0x4115, 0x4215, 0x4311, 0x4415, 0x4511,
    0x4001, 0x4105, 0x4205, 0x4301, 0x4405, 0x4501, 0x4601, 0x4705,
    0x480D, 0x4909, 0x5015, 0x5111, 0x5211, 0x5315, 0x5411, 0x5515,
    0x5005, 0x5101, 0x5201, 0x5305, 0x5401, 0x5505, 0x5605, 0x5701,
    0x5809, 0x590D, 0x6035, 0x6131, 0x6231, 0x6335, 0x6431, 0x6535,
    0x0046, 0x0102, 0x0202, 0x0306, 0x0402, 0x0506, 0x0606, 0x0702,
    0x080A, 0x090E, 0x0402, 0x0506, 0x0606, 0x0702, 0x080A, 0x090E,
    0x1002, 0x1106, 0x1206, 0x1302, 0x1406, 0x1502, 0x1602, 0x1706,
    0x180E, 0x190A, 0x1406, 0x1502, 0x1602, 0x1706, 0x180E, 0x190A,
    0x2022, 0x2126, 0x2226, 0x2322, 0x2426, 0x2522, 0x2622, 0x2726,
    0x282E, 0x292A, 0x2426, 0x2522, 0x2622, 0x2726, 0x282E, 0x292A,
    0x3026, 0x3122, 0x3222, 0x3326, 0x3422, 0x3526, 0x3626, 0x3722,
    0x382A, 0x392E, 0x3422, 0x3526, 0x3626, 0x3722, 0x382A, 0x392E,
    0x4002, 0x4106, 0x4206, 0x4302, 0x4406, 0x4502, 0x4602, 0x4706,
    0x480E, 0x490A, 0x4406, 0x4502, 0x4602, 0x4706, 0x480E, 0x490A,
    0x5006, 0x5102, 0x5202, 0x5306, 0x5402, 0x5506, 0x5606, 0x5702,
    0x580A, 0x590E, 0x5402, 0x5506, 0x5606, 0x5702, 0x580A, 0x590E,
    0x6026, 0x6122, 0x6222, 0x6326, 0x6422, 0x6526, 0x6626, 0x6722,
    0x682A, 0x692E, 0x6422, 0x6526, 0x6626, 0x6722, 0x682A, 0x692E,
    0x7022, 0x7126, 0x7226, 0x7322, 0x7426, 0x7522, 0x7622, 0x7726,
    0x782E, 0x792A, 0x7426, 0x7522, 0x7622, 0x7726, 0x782E, 0x792A,
    0x8082, 0x8186, 0x8286, 0x8382, 0x8486, 0x8582, 0x8682, 0x8786,
    0x888E, 0x898A, 0x8486, 0x8582, 0x8682, 0x8786, 0x888E, 0x898A,
    0x9086, 0x9182, 0x9282, 0x9386, 0x9482, 0x9586, 0x9686, 0x9782,
    0x988A, 0x998E, 0x3423, 0x3527, 0x3627, 0x3723, 0x382B, 0x392F,
    0x4003, 0x4107, 0x4207, 0x4303, 0x4407, 0x4503, 0x4603, 0x4707,
    0x480F, 0x490B, 0x4407, 0x4503, 0x4603, 0x4707, 0x480F, 0x490B,
    0x5007, 0x5103, 0x5203, 0x5307, 0x5403, 0x5507, 0x5607, 0x5703,
    0x580B, 0x590F, 0x5403, 0x5507, 0x5607, 0x5703, 0x580B, 0x590F,
    0x6027, 0x6123, 0x6223, 0x6327, 0x6423, 0x6527, 0x6627, 0x6723,
    0x682B, 0x692F, 0x6423, 0x6527, 0x6627, 0x6723, 0x682B, 0x692F,
    0x7023, 0x7127, 0x7227, 0x7323, 0x7427, 0x7523, 0x7623, 0x7727,
    0x782F, 0x792B, 0x7427, 0x7523, 0x7623, 0x7727, 0x782F, 0x792B,
    0x8083, 0x8187, 0x8287, 0x8383, 0x8487, 0x8583, 0x8683, 0x8787,
    0x888F, 0x898B, 0x8487, 0x8583, 0x8683, 0x8787, 0x888F, 0x898B,
    0x9087, 0x9183, 0x9283, 0x9387, 0x9483, 0x9587, 0x9687, 0x9783,
    0x988B, 0x998F, 0x9483, 0x9587, 0x9687, 0x9783, 0x988B, 0x998F,
    0xA0A7, 0xA1A3, 0xA2A3, 0xA3A7, 0xA4A3, 0xA5A7, 0xA6A7, 0xA7A3,
    0xA8AB, 0xA9AF, 0xA4A3, 0xA5A7, 0xA6A7, 0xA7A3, 0xA8AB, 0xA9AF,
    0xB0A3, 0xB1A7, 0xB2A7, 0xB3A3, 0xB4A7, 0xB5A3, 0xB6A3, 0xB7A7,
    0xB8AF, 0xB9AB, 0xB4A7, 0xB5A3, 0xB6A3, 0xB7A7, 0xB8AF, 0xB9AB,
    0xC087, 0xC183, 0xC283, 0xC387, 0xC483, 0xC587, 0xC687, 0xC783,
    0xC88B, 0xC98F, 0xC483, 0xC587, 0xC687, 0xC783, 0xC88B, 0xC98F,
    0xD083, 0xD187, 0xD287, 0xD383, 0xD487, 0xD583, 0xD683, 0xD787,
    0xD88F, 0xD98B, 0xD487, 0xD583, 0xD683, 0xD787, 0xD88F, 0xD98B,
    0xE0A3, 0xE1A7, 0xE2A7, 0xE3A3, 0xE4A7, 0xE5A3, 0xE6A3, 0xE7A7,
    0xE8AF, 0xE9AB, 0xE4A7, 0xE5A3, 0xE6A3, 0xE7A7, 0xE8AF, 0xE9AB,
    0xF0A7, 0xF1A3, 0xF2A3, 0xF3A7, 0xF4A3, 0xF5A7, 0xF6A7, 0xF7A3,
    0xF8AB, 0xF9AF, 0xF4A3, 0xF5A7, 0xF6A7, 0xF7A3, 0xF8AB, 0xF9AF,
    0x0047, 0x0103, 0x0203, 0x0307, 0x0403, 0x0507, 0x0607, 0x0703,
    0x080B, 0x090F, 0x0403, 0x0507, 0x0607, 0x0703, 0x080B, 0x090F,
    0x1003, 0x1107, 0x1207, 0x1303, 0x1407, 0x1503, 0x1603, 0x1707,
    0x180F, 0x190B, 0x1407, 0x1503, 0x1603, 0x1707, 0x180F, 0x190B,
    0x2023, 0x2127, 0x2227, 0x2323, 0x2427, 0x2523, 0x2623, 0x2727,
    0x282F, 0x292B, 0x2427, 0x2523, 0x2623, 0x2727, 0x282F, 0x292B,
    0x3027, 0x3123, 0x3223, 0x3327, 0x3423, 0x3527, 0x3627, 0x3723,
    0x382B, 0x392F, 0x3423, 0x3527, 0x3627, 0x3723, 0x382B, 0x392F,
    0x4003, 0x4107, 0x4207, 0x4303, 0x4407, 0x4503, 0x4603, 0x4707,
    0x480F, 0x490B, 0x4407, 0x4503, 0x4603, 0x4707, 0x480F, 0x490B,
    0x5007, 0x5103, 0x5203, 0x5307, 0x5403, 0x5507, 0x5607, 0x5703,
    0x580B, 0x590F, 0x5403, 0x5507, 0x5607, 0x5703, 0x580B, 0x590F,
    0x6027, 0x6123, 0x6223, 0x6327, 0x6423, 0x6527, 0x6627, 0x6723,
    0x682B, 0x692F, 0x6423, 0x6527, 0x6627, 0x6723, 0x682B, 0x692F,
    0x7023, 0x7127, 0x7227, 0x7323, 0x7427, 0x7523, 0x7623, 0x7727,
    0x782F, 0x792B, 0x7427, 0x7523, 0x7623, 0x7727, 0x782F, 0x792B,
    0x8083, 0x8187, 0x8287, 0x8383, 0x8487, 0x8583, 0x8683, 0x8787,
    0x888F, 0x898B, 0x8487, 0x8583, 0x8683, 0x8787, 0x888F, 0x898B,
    0x9087, 0x9183, 0x9283, 0x9387, 0x9483, 0x9587, 0x9687, 0x9783,
    0x988B, 0x998F, 0x9483, 0x9587, 0x9687, 0x9783, 0x988B, 0x998F,
    0x0604, 0x0700, 0x0808, 0x090C, 0x0A0C, 0x0B08, 0x0C0C, 0x0D08,
    0x0E08, 0x0F0C, 0x1010, 0x1114, 0x1214, 0x1310, 0x1414, 0x1510,
    0x1600, 0x1704, 0x180C, 0x1908, 0x1A08, 0x1B0C, 0x1C08, 0x1D0C,
    0x1E0C, 0x1F08, 0x2030, 0x2134, 0x2234, 0x2330, 0x2434, 0x2530,
    0x2620, 0x2724, 0x282C, 0x2928, 0x2A28, 0x2B2C, 0x2C28, 0x2D2C,
    0x2E2C, 0x2F28, 0x3034, 0x3130, 0x3230, 0x3334, 0x3430, 0x3534,
    0x3624, 0x3720, 0x3828, 0x392C, 0x3A2C, 0x3B28, 0x3C2C, 0x3D28,
    0x3E28, 0x3F2C, 0x4010, 0x4114, 0x4214, 0x4310, 0x4414, 0x4510,
    0x4600, 0x4704, 0x480C, 0x4908, 0x4A08, 0x4B0C, 0x4C08, 0x4D0C,
    0x4E0C, 0x4F08, 0x5014, 0x5110, 0x5210, 0x5314, 0x5410, 0x5514,
    0x5604, 0x5700, 0x5808, 0x590C, 0x5A0C, 0x5B08, 0x5C0C, 0x5D08,
    0x5E08, 0x5F0C, 0x6034, 0x6130, 0x6230, 0x6334, 0x6430, 0x6534,
    0x6624, 0x6720, 0x6828, 0x692C, 0x6A2C, 0x6B28, 0x6C2C, 0x6D28,
    0x6E28, 0x6F2C, 0x7030, 0x7134, 0x7234, 0x7330, 0x7434, 0x7530,
    0x7620, 0x7724, 0x782C, 0x7928, 0x7A28, 0x7B2C, 0x7C28, 0x7D2C,
    0x7E2C, 0x7F28, 0x8090, 0x8194, 0x8294, 0x8390, 0x8494, 0x8590,
    0x8680, 0x8784, 0x888C, 0x8988, 0x8A88, 0x8B8C, 0x8C88, 0x8D8C,
    0x8E8C, 0x8F88, 0x9094, 0x9190, 0x9290, 0x9394, 0x9490, 0x9594,
    0x9684, 0x9780, 0x9888, 0x998C, 0x9A8C, 0x9B88, 0x9C8C, 0x9D88,
    0x9E88, 0x9F8C, 0x0055, 0x0111, 0x0211, 0x0315, 0x0411, 0x0515,
    0x0605, 0x0701, 0x0809, 0x090D, 0x0A0D, 0x0B09, 0x0C0D, 0x0D09,
    0x0E09, 0x0F0D, 0x1011, 0x1115, 0x1215, 0x1311, 0x1415, 0x1511,
    0x1601, 0x1705, 0x180D, 0x1909, 0x1A09, 0x1B0D, 0x1C09, 0x1D0D,
    0x1E0D, 0x1F09, 0x2031, 0x2135, 0x2235, 0x2331, 0x2435, 0x2531,
    0x2621, 0x2725, 0x282D, 0x2929, 0x2A29, 0x2B2D, 0x2C29, 0x2D2D,
    0x2E2D, 0x2F29, 0x3035, 0x3131, 0x3231, 0x3335, 0x3431, 0x3535,
    0x3625, 0x3721, 0x3829, 0x392D, 0x3A2D, 0x3B29, 0x3C2D, 0x3D29,
    0x3E29, 0x3F2D, 0x4011, 0x4115, 0x4215, 0x4311, 0x4415, 0x4511,
    0x4601, 0x4705, 0x480D, 0x4909, 0x4A09, 0x4B0D, 0x4C09, 0x4D0D,
    0x4E0D, 0x4F09, 0x5015, 0x5111, 0x5211, 0x5315, 0x5411, 0x5515,
    0x5605, 0x5701, 0x5809, 0x590D, 0x5A0D, 0x5B09, 0x5C0D, 0x5D09,
    0x5E09, 0x5F0D, 0x6035, 0x6131, 0x6231, 0x6335, 0x6431, 0x6535,
    0x6625, 0x6721, 0x6829, 0x692D, 0x6A2D, 0x6B29, 0x6C2D, 0x6D29,
    0x6E29, 0x6F2D, 0x7031, 0x7135, 0x7235, 0x7331, 0x7435, 0x7531,
    0x7621, 0x7725, 0x782D, 0x7929, 0x7A29, 0x7B2D, 0x7C29, 0x7D2D,
    0x7E2D, 0x7F29, 0x8091, 0x8195, 0x8295, 0x8391, 0x8495, 0x8591,
    0x8681, 0x8785, 0x888D, 0x8989, 0x8A89, 0x8B8D, 0x8C89, 0x8D8D,
    0x8E8D, 0x8F89, 0x9095, 0x9191, 0x9291, 0x9395, 0x9491, 0x9595,
    0x9685, 0x9781, 0x9889, 0x998D, 0x9A8D, 0x9B89, 0x9C8D, 0x9D89,
    0x9E89, 0x9F8D, 0xA0B5, 0xA1B1, 0xA2B1, 0xA3B5, 0xA4B1, 0xA5B5,
    0xA6A5, 0xA7A1, 0xA8A9, 0xA9AD, 0xAAAD, 0xABA9, 0xACAD, 0xADA9,
    0xAEA9, 0xAFAD, 0xB0B1, 0xB1B5, 0xB2B5, 0xB3B1, 0xB4B5, 0xB5B1,
    0xB6A1, 0xB7A5, 0xB8AD, 0xB9A9, 0xBAA9, 0xBBAD, 0xBCA9, 0xBDAD,
    0xBEAD, 0xBFA9, 0xC095, 0xC191, 0xC291, 0xC395, 0xC491, 0xC595,
    0xC685, 0xC781, 0xC889, 0xC98D, 0xCA8D, 0xCB89, 0xCC8D, 0xCD89,
    0xCE89, 0xCF8D, 0xD091, 0xD195, 0xD295, 0xD391, 0xD495, 0xD591,
    0xD681, 0xD785, 0xD88D, 0xD989, 0xDA89, 0xDB8D, 0xDC89, 0xDD8D,
    0xDE8D, 0xDF89, 0xE0B1, 0xE1B5, 0xE2B5, 0xE3B1, 0xE4B5, 0xE5B1,
    0xE6A1, 0xE7A5, 0xE8AD, 0xE9A9, 0xEAA9, 0xEBAD, 0xECA9, 0xEDAD,
    0xEEAD, 0xEFA9, 0xF0B5, 0xF1B1, 0xF2B1, 0xF3B5, 0xF4B1, 0xF5B5,
    0xF6A5, 0xF7A1, 0xF8A9, 0xF9AD, 0xFAAD, 0xFBA9, 0xFCAD, 0xFDA9,
    0xFEA9, 0xFFAD, 0x0055, 0x0111, 0x0211, 0x0315, 0x0411, 0x0515,
    0x0605, 0x0701, 0x0809, 0x090D, 0x0A0D, 0x0B09, 0x0C0D, 0x0D09,
    0x0E09, 0x0F0D, 0x1011, 0x1115, 0x1215, 0x1311, 0x1415, 0x1511,
    0x1601, 0x1705, 0x180D, 0x1909, 0x1A09, 0x1B0D, 0x1C09, 0x1D0D,
    0x1E0D, 0x1F09, 0x2031, 0x2135, 0x2235, 0x2331, 0x2435, 0x2531,
    0x2621, 0x2725, 0x282D, 0x2929, 0x2A29, 0x2B2D, 0x2C29, 0x2D2D,
    0x2E2D, 0x2F29, 0x3035, 0x3131, 0x3231, 0x3335, 0x3431, 0x3535,
    0x3625, 0x3721, 0x3829, 0x392D, 0x3A2D, 0x3B29, 0x3C2D, 0x3D29,
    0x3E29, 0x3F2D, 0x4011, 0x4115, 0x4215, 0x4311, 0x4415, 0x4511,
    0x4601, 0x4705, 0x480D, 0x4909, 0x4A09, 0x4B0D, 0x4C09, 0x4D0D,
    0x4E0D, 0x4F09, 0x5015, 0x5111, 0x5211, 0x5315, 0x5411, 0x5515,
    0x5605, 0x5701, 0x5809, 0x590D, 0x5A0D, 0x5B09, 0x5C0D, 0x5D09,
    0x5E09, 0x5F0D, 0x6035, 0x6131, 0x6231, 0x6335, 0x6431, 0x6535,
    0xFABE, 0xFBBA, 0xFCBE, 0xFDBA, 0xFEBA, 0xFFBE, 0x0046, 0x0102,
    0x0202, 0x0306, 0x0402, 0x0506, 0x0606, 0x0702, 0x080A, 0x090E,
    0x0A1E, 0x0B1A, 0x0C1E, 0x0D1A, 0x0E1A, 0x0F1E, 0x1002, 0x1106,
    0x1206, 0x1302, 0x1406, 0x1502, 0x1602, 0x1706, 0x180E, 0x190A,
    0x1A1A, 0x1B1E, 0x1C1A, 0x1D1E, 0x1E1E, 0x1F1A, 0x2022, 0x2126,
    0x2226, 0x2322, 0x2426, 0x2522, 0x2622, 0x2726, 0x282E, 0x292A,
    0x2A3A, 0x2B3E, 0x2C3A, 0x2D3E, 0x2E3E, 0x2F3A, 0x3026, 0x3122,
    0x3222, 0x3326, 0x3422, 0x3526, 0x3626, 0x3722, 0x382A, 0x392E,
    0x3A3E, 0x3B3A, 0x3C3E, 0x3D3A, 0x3E3A, 0x3F3E, 0x4002, 0x4106,
    0x4206, 0x4302, 0x4406, 0x4502, 0x4602, 0x4706, 0x480E, 0x490A,
    0x4A1A, 0x4B1E, 0x4C1A, 0x4D1E, 0x4E1E, 0x4F1A, 0x5006, 0x5102,
    0x5202, 0x5306, 0x5402, 0x5506, 0x5606, 0x5702, 0x580A, 0x590E,
    0x5A1E, 0x5B1A, 0x5C1E, 0x5D1A, 0x5E1A, 0x5F1E, 0x6026, 0x6122,
    0x6222, 0x6326, 0x6422, 0x6526, 0x6626, 0x6722, 0x682A, 0x692E,
    0x6A3E, 0x6B3A, 0x6C3E, 0x6D3A, 0x6E3A, 0x6F3E, 0x7022, 0x7126,
    0x7226, 0x7322, 0x7426, 0x7522, 0x7622, 0x7726, 0x782E, 0x792A,
    0x7A3A, 0x7B3E, 0x7C3A, 0x7D3E, 0x7E3E, 0x7F3A, 0x8082, 0x8186,
    0x8286, 0x8382, 0x8486, 0x8582, 0x8682, 0x8786, 0x888E, 0x898A,
    0x8A9A, 0x8B9E, 0x8C9A, 0x8D9E, 0x8E9E, 0x8F9A, 0x9086, 0x9182,
    0x9282, 0x9386, 0x3423, 0x3527, 0x3627, 0x3723, 0x382B, 0x392F,
    0x3A3F, 0x3B3B, 0x3C3F, 0x3D3B, 0x3E3B, 0x3F3F, 0x4003, 0x4107,
    0x4207, 0x4303, 0x4407, 0x4503, 0x4603, 0x4707, 0x480F, 0x490B,
    0x4A1B, 0x4B1F, 0x4C1B, 0x4D1F, 0x4E1F, 0x4F1B, 0x5007, 0x5103,
    0x5203, 0x5307, 0x5403, 0x5507, 0x5607, 0x5703, 0x580B, 0x590F,
    0x5A1F, 0x5B1B, 0x5C1F, 0x5D1B, 0x5E1B, 0x5F1F, 0x6027, 0x6123,
    0x6223, 0x6327, 0x6423, 0x6527, 0x6627, 0x6723, 0x682B, 0x692F,
    0x6A3F, 0x6B3B, 0x6C3F, 0x6D3B, 0x6E3B, 0x6F3F, 0x7023, 0x7127,
    0x7227, 0x7323, 0x7427, 0x7523, 0x7623, 0x7727, 0x782F, 0x792B,
    0x7A3B, 0x7B3F, 0x7C3B, 0x7D3F, 0x7E3F, 0x7F3B, 0x8083, 0x8187,
    0x8287, 0x8383, 0x8487, 0x8583, 0x8683, 0x8787, 0x888F, 0x898B,
    0x8A9B, 0x8B9F, 0x8C9B, 0x8D9F, 0x8E9F, 0x8F9B, 0x9087, 0x9183,
    0x9283, 0x9387, 0x9483, 0x9587, 0x9687, 0x9783, 0x988B, 0x998F,
    0x9A9F, 0x9B9B, 0x9C9F, 0x9D9B, 0x9E9B, 0x9F9F, 0xA0A7, 0xA1A3,
    0xA2A3, 0xA3A7, 0xA4A3, 0xA5A7, 0xA6A7, 0xA7A3, 0xA8AB, 0xA9AF,
    0xAABF, 0xABBB, 0xACBF, 0xADBB, 0xAEBB, 0xAFBF, 0xB0A3, 0xB1A7,
    0xB2A7, 0xB3A3, 0xB4A7, 0xB5A3, 0xB6A3, 0xB7A7, 0xB8AF, 0xB9AB,
    0xBABB, 0xBBBF, 0xBCBB, 0xBDBF, 0xBEBF, 0xBFBB, 0xC087, 0xC183,
    0xC283, 0xC387, 0xC483, 0xC587, 0xC687, 0xC783, 0xC88B, 0xC98F,
    0xCA9F, 0xCB9B, 0xCC9F, 0xCD9B, 0xCE9B, 0xCF9F, 0xD083, 0xD187,
    0xD287, 0xD383, 0xD487, 0xD583, 0xD683, 0xD787, 0xD88F, 0xD98B,
    0xDA9B, 0xDB9F, 0xDC9B, 0xDD9F, 0xDE9F, 0xDF9B, 0xE0A3, 0xE1A7,
    0xE2A7, 0xE3A3, 0xE4A7, 0xE5A3, 0xE6A3, 0xE7A7, 0xE8AF, 0xE9AB,
    0xEABB, 0xEBBF, 0xECBB, 0xEDBF, 0xEEBF, 0xEFBB, 0xF0A7, 0xF1A3,
    0xF2A3, 0xF3A7, 0xF4A3, 0xF5A7, 0xF6A7, 0xF7A3, 0xF8AB, 0xF9AF,
    0xFABF, 0xFBBB, 0xFCBF, 0xFDBB, 0xFEBB, 0xFFBF, 0x0047, 0x0103,
    0x0203, 0x0307, 0x0403, 0x0507, 0x0607, 0x0703, 0x080B, 0x090F,
    0x0A1F, 0x0B1B, 0x0C1F, 0x0D1B, 0x0E1B, 0x0F1F, 0x1003, 0x1107,
    0x1207, 0x1303, 0x1407, 0x1503, 0x1603, 0x1707, 0x180F, 0x190B,
    0x1A1B, 0x1B1F, 0x1C1B, 0x1D1F, 0x1E1F, 0x1F1B, 0x2023, 0x2127,
    0x2227, 0x2323, 0x2427, 0x2523, 0x2623, 0x2727, 0x282F, 0x292B,
    0x2A3B, 0x2B3F, 0x2C3B, 0x2D3F, 0x2E3F, 0x2F3B, 0x3027, 0x3123,
    0x3223, 0x3327, 0x3423, 0x3527, 0x3627, 0x3723, 0x382B, 0x392F,
    0x3A3F, 0x3B3B, 0x3C3F, 0x3D3B, 0x3E3B, 0x3F3F, 0x4003, 0x4107,
    0x4207, 0x4303, 0x4407, 0x4503, 0x4603, 0x4707, 0x480F, 0x490B,
    0x4A1B, 0x4B1F, 0x4C1B, 0x4D1F, 0x4E1F, 0x4F1B, 0x5007, 0x5103,
    0x5203, 0x5307, 0x5403, 0x5507, 0x5607, 0x5703, 0x580B, 0x590F,
    0x5A1F, 0x5B1B, 0x5C1F, 0x5D1B, 0x5E1B, 0x5F1F, 0x6027, 0x6123,
    0x6223, 0x6327, 0x6423, 0x6527, 0x6627, 0x6723, 0x682B, 0x692F,
    0x6A3F, 0x6B3B, 0x6C3F, 0x6D3B, 0x6E3B, 0x6F3F, 0x7023, 0x7127,
    0x7227, 0x7323, 0x7427, 0x7523, 0x7623, 0x7727, 0x782F, 0x792B,
    0x7A3B, 0x7B3F, 0x7C3B, 0x7D3F, 0x7E3F, 0x7F3B, 0x8083, 0x8187,
    0x8287, 0x8383, 0x8487, 0x8583, 0x8683, 0x8787, 0x888F, 0x898B,
    0x8A9B, 0x8B9F, 0x8C9B, 0x8D9F, 0x8E9F, 0x8F9B, 0x9087, 0x9183,
    0x9283, 0x9387, 0x9483, 0x9587, 0x9687, 0x9783, 0x988B, 0x998F
};


/********************************************************* !NAME! **************
 * Nom : Parite
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Variables Globales
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Calcul du flag P, V, S, Z d'un registre 8 bits
 *
 ********************************************************** !0! ****************/
static UBYTE Parite[ 256 ] =
{
    0x44, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
    0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
    0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
    0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
    0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
    0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
    0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
    0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
    0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
    0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
    0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
    0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
    0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
    0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
    0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
    0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
    0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84,
    0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
    0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
    0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84,
    0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
    0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84,
    0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84,
    0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
    0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
    0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84,
    0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84,
    0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
    0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84,
    0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
    0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
    0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84
};


/********************************************************* !NAME! **************
 * Nom : CBIndex
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Variables Globales
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Indique si l'instruction CB est précédée d'une instruction DD
 *               ou d'une instruction FD
 *
 ********************************************************** !0! ****************/
static int CBIndex = 0;


/********************************************************* !NAME! **************
 * Nom : Peek8Ext
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Lecture d'un octet (8 bits) depuis la mémoire du CPC (utilisée
 *               depuis l'extérieur du module)
 *
 * Résultat    : La valeur de l'octet a l'adresse désirée
 *
 * Variables globales modifiées : /
 *
 ********************************************************** !0! ****************/
UBYTE Peek8Ext( core_crocods_t *core, USHORT adr )
{
    UBYTE val = core->TabPEEK[ adr >> 14 ][ adr & MASK_14BIT ];
    return( val );
}


/********************************************************* !NAME! **************
 * Nom : Poke8Ext
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Ecriture d'un octet (8 bits) dans la mémoire du CPC (utilisée
 *               depuis l'extérieur du module)
 *
 * Résultat    : /
 *
 * Variables globales modifiées : /
 *
 ********************************************************** !0! ****************/
void Poke8Ext( core_crocods_t *core, USHORT adr, UBYTE val )
{
    core->TabPOKE[ adr >> 14 ][ adr & MASK_14BIT ] = val;
}


/********************************************************* !NAME! **************
 * Nom : PEEK8
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Lecture d'un octet (8 bits) depuis la mémoire du CPC
 *
 * Résultat    : La valeur de l'octet a l'adresse désirée
 *
 * Variables globales modifiées : /
 *
 ********************************************************** !0! ****************/
static u8 PEEK8( core_crocods_t *core, u16 adr )
{
    // myprintf("R8: %d", adr);
    return( core->TabPEEK[ adr >> 14 ][ adr & MASK_14BIT ] );
}


/********************************************************* !NAME! **************
 * Nom : POKE8
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Ecriture d'un octet (8 bits) dans la mémoire du CPC
 *
 * Résultat    : /
 *
 * Variables globales modifiées : /
 *
 ********************************************************** !0! ****************/
static void POKE8( core_crocods_t *core, u16 adr, u8 val )
{
    core->TabPOKE[ adr >> 14 ][ adr & MASK_14BIT ] = val;
}

//static void POKEPEEK8( core_crocods_t *core, u16 adr, u16 adr2)
//{
//    core->TabPOKE[ adr >> 14 ][ adr & MASK_14BIT ] = core->TabPEEK[ adr2 >> 14 ][ adr2 & MASK_14BIT ];
//}

/********************************************************* !NAME! **************
 * Nom : PEEK16
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Lecture d'un mot (16 bits) depuis la mémoire du CPC
 *
 * Résultat    : La valeur du mot a l'adresse désirée
 *
 * Variables globales modifiées : /
 *
 ********************************************************** !0! ****************/
static u16 PEEK16( core_crocods_t *core, u16 adr )
{
    // myprintf("R16: %d", adr);
    u16 p = adr & MASK_14BIT;
    u16 q = adr >> 14;
    return( ( USHORT )( core->TabPEEK[ q ][ p ] | ( core->TabPEEK[ q ][ p + 1 ] << 8 ) ) );
}


/********************************************************* !NAME! **************
 * Nom : POKE16
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Ecriture d'un mot (16 bits) dans la mémoire du CPC
 *
 * Résultat    : /
 *
 * Variables globales modifiées : /
 *
 ********************************************************** !0! ****************/
static void POKE16( core_crocods_t *core, u16 adr, u16 val )
{
    u16 p = adr & MASK_14BIT;
    u16 q = adr >> 14;
    core->TabPOKE[ q ][ p ] = ( UBYTE )val;
    core->TabPOKE[ q ][ p + 1 ] = ( UBYTE )( val >> 8 );
}


/********************************************************* !NAME! **************
 * Nom : ADD_R8
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Effectue une addition 8 Bits
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void ADD_R8( core_crocods_t *core, int v )
{
    int t = RegA + v;
    
    FLAGS = ( UBYTE )( ( ~( RegA ^ v ) & ( v ^ t ) & 0x80 ? FLAG_V : 0 )
                      | ( t >> 8 )
                      | ( t & FLAG_S )
                      | ( ( t & 0xFF ) ? 0 : FLAG_Z )
                      | ( ( RegA ^ v ^ t ) & FLAG_H )
                      );
    RegA = ( UBYTE )t;
}


/********************************************************* !NAME! **************
 * Nom : SUB_R8
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Effectue une soustration 8 bits
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void SUB_R8( core_crocods_t *core, int v )
{
    int t = RegA - v;
    
    FLAGS = ( UBYTE )( ( ( RegA ^ v ) & ( RegA ^ t ) & 0x80 ? FLAG_V : 0 )
                      | FLAG_N
                      | - ( t >> 8 )
                      | ( t & FLAG_S )
                      | ( ( t & 0xFF ) ? 0 : FLAG_Z )
                      | ( ( RegA ^ v ^ t ) & FLAG_H )
                      );
    RegA = ( UBYTE )t;
}


/********************************************************* !NAME! **************
 * Nom : ADC_R8
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Effectue une addition 8 bits avec carry
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void ADC_R8( core_crocods_t *core, int v )
{
    int t = RegA + v + ( FLAGS & FLAG_C );
    
    FLAGS = ( UBYTE )( ( ~( RegA ^ v ) & ( v ^ t ) & 0x80 ? FLAG_V : 0 )
                      | ( t >> 8 )
                      | ( t & FLAG_S )
                      | ( ( t & 0xFF ) ? 0 : FLAG_Z )
                      | ( ( RegA ^ v ^ t ) & FLAG_H )
                      );
    RegA = ( UBYTE )t;
}


/********************************************************* !NAME! **************
 * Nom : SBC_R8
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Effectue une soustraction 8 bits avec carry
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void SBC_R8( core_crocods_t *core, int v )
{
    int t = RegA - v - ( FLAGS & FLAG_C );
    
    FLAGS = ( UBYTE )( ( ( RegA ^ v ) & ( RegA ^ t ) & 0x80 ? FLAG_V : 0 )
                      | FLAG_N
                      | - ( t >> 8 )
                      | ( t & FLAG_S )
                      | ( ( t & 0xFF ) ? 0 : FLAG_Z )
                      | ( ( RegA ^ v ^ t ) & FLAG_H )
                      );
    RegA = ( UBYTE )t;
}


/********************************************************* !NAME! **************
 * Nom : CP_R8
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Effectue une comparaision 8 bits
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void CP_R8( core_crocods_t *core, int v )
{
    int t = RegA - v;
    
    FLAGS = ( UBYTE )( ( ( RegA ^ v ) & ( RegA ^ t ) & 0x80 ? FLAG_V : 0 )
                      | FLAG_N
                      | - ( t >> 8 )
                      | ( t & FLAG_S )
                      | ( ( t & 0xFF ) ? 0 : FLAG_Z )
                      | ( ( RegA ^ v ^ t ) & FLAG_H )
                      );
}


/********************************************************* !NAME! **************
 * Nom : FLAG_INC
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Affecte les flags après une instruction d'incrémentation
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void FLAG_INC( core_crocods_t *core, int reg )
{
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C )
                      | ( reg & FLAG_S )
                      | ( reg == 0x80 ? FLAG_V : 0 )
                      | ( ( reg & 0x0F ) == 0 ? FLAG_H : 0 )
                      | ( reg ? 0 : FLAG_Z )
                      );
}


/********************************************************* !NAME! **************
 * Nom : FLAG_DEC
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Affecte les flags après une instruction de décrémentation
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void FLAG_DEC( core_crocods_t *core, int reg )
{
    FLAGS = ( UBYTE )( FLAG_N
                      | ( FLAGS & FLAG_C )
                      | ( reg == 0x7F ? FLAG_V : 0 )
                      | ( ( reg & 0x0F ) == 0x0F ? FLAG_H : 0 )
                      | ( reg & FLAG_S )
                      | ( reg ? 0 : FLAG_Z )
                      );
}


/********************************************************* !NAME! **************
 * Nom : ADD_R16
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Effectue une addition 16 bits
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void ADD_R16( core_crocods_t *core, USHORT * Reg, int v )
{
    int tmp = * Reg;
    * Reg = ( USHORT )( * Reg + v );
    
    FLAGS = ( UBYTE )( FLAGS & ( FLAG_S | FLAG_Z | FLAG_V ) );
    if ( tmp > * Reg )
        FLAGS |= FLAG_C;
    
    if ( ( tmp ^ v ^ * Reg ) & 0x1000 )
        FLAGS |= FLAG_H;
}


/********************************************************* !NAME! **************
 * Nom : ADC_R16
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Effectue une addition 16 bits avec carry
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void ADC_R16( core_crocods_t *core, int v )
{
    int t = RegHL + v + ( FLAGS & FLAG_C );
    
    FLAGS = ( UBYTE )( ( t & 0x10000 ? FLAG_C : 0 )
                      | ( ~ ( RegHL ^ v ) & ( v ^ t ) & 0x8000 ? FLAG_V : 0 )
                      | ( ( RegHL ^ v ^ t ) & 0x1000 ? FLAG_H : 0 )
                      | ( t & 0xFFFF ? 0 : FLAG_Z )
                      | ( ( t >> 8 ) & FLAG_S )
                      );
    RegHL = ( USHORT )t;
}


/********************************************************* !NAME! **************
 * Nom : SBC_R16
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Effectue une soustraction 16 bits avec carry
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void SBC_R16( core_crocods_t *core, int v )
{
    int t = RegHL - v - ( FLAGS & FLAG_C );
    
    FLAGS = ( UBYTE )( FLAG_N
                      | ( t & 0x10000 ? FLAG_C : 0 )
                      | ( ( RegHL ^ v ) & ( RegHL ^ t ) & 0x8000 ? FLAG_V : 0 )
                      | ( ( RegHL ^ v ^ t ) & 0x1000 ? FLAG_H : 0 )
                      | ( t & 0xFFFF ? 0 : FLAG_Z )
                      | ( (  t >> 8  ) & FLAG_S )
                      );
    RegHL = ( USHORT )t;
}


/********************************************************* !NAME! **************
 * Nom : Bit
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Teste un bit d'un registre
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
static void Bit( core_crocods_t *core, UBYTE r, UBYTE Bit )
{
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | FLAG_H | Parite[ r & Bit ] );
}


/************
 * OPCODE CB *
 ************/


static int CB_00( core_crocods_t *core )   /* RLC B */
{
    FLAGS = ( UBYTE )( RegB >> 7 );
    RegB = ( UBYTE )( ( RegB << 1 ) | FLAGS );
    FLAGS |= Parite[ RegB ];
    if ( CBIndex )
        POKE8( core, RegHL, RegB );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_01( core_crocods_t *core )   /* RLC C */
{
    FLAGS = ( UBYTE )( RegC >> 7 );
    RegC = ( UBYTE )( ( RegC << 1 ) | FLAGS );
    FLAGS |= Parite[ RegC ];
    if ( CBIndex )
        POKE8( core, RegHL, RegC );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_02( core_crocods_t *core )   /* RLC D */
{
    FLAGS = ( UBYTE )( RegD >> 7 );
    RegD = ( UBYTE )( ( RegD << 1 ) | FLAGS );
    FLAGS |= Parite[ RegD ];
    if ( CBIndex )
        POKE8( core, RegHL, RegD );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_03( core_crocods_t *core )   /* RLC E */
{
    FLAGS = ( UBYTE )( RegE >> 7 );
    RegE = ( UBYTE )( ( RegE << 1 ) | FLAGS );
    FLAGS |= Parite[ RegE ];
    if ( CBIndex )
        POKE8( core, RegHL, RegE );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_04( core_crocods_t *core )   /* RLC H */
{
    FLAGS = ( UBYTE )( RegH >> 7 );
    RegH = ( UBYTE )( ( RegH << 1 ) | FLAGS );
    FLAGS |= Parite[ RegH ];
    if ( CBIndex )
        POKE8( core, RegHL, RegH );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_05( core_crocods_t *core )   /* RLC L */
{
    FLAGS = ( UBYTE )( RegL >> 7 );
    RegL = ( UBYTE )( ( RegL << 1 ) | FLAGS );
    FLAGS |= Parite[ RegL ];
    if ( CBIndex )
        POKE8( core, RegHL, RegL );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_06( core_crocods_t *core )   /* RLC (HL) */
{
    int hl = PEEK8( core, RegHL );
    FLAGS = ( UBYTE )( hl >> 7 );
    POKE8( core, RegHL , ( UBYTE )( hl = ( ( hl << 1 ) | FLAGS ) ) );
    FLAGS |= Parite[ hl ];
    return( 4 /* 4 NOPs */ );
}


static int CB_07( core_crocods_t *core )   /* RLC A */
{
    FLAGS = ( UBYTE )( RegA >> 7 );
    RegA = ( UBYTE )( ( RegA << 1 ) | FLAGS );
    FLAGS |= Parite[ RegA ];
    if ( CBIndex )
        POKE8( core, RegHL, RegA );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_08( core_crocods_t *core )   /* RRC B */
{
    FLAGS = ( UBYTE )( RegB & FLAG_C );
    RegB = ( UBYTE )( ( RegB >> 1 ) | ( FLAGS << 7 ) );
    FLAGS |= Parite[ RegB ];
    if ( CBIndex )
        POKE8( core, RegHL, RegB );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_09( core_crocods_t *core )   /* RRC C */
{
    FLAGS = ( UBYTE )( RegC & FLAG_C );
    RegC = ( UBYTE )( ( RegC >> 1 ) | ( FLAGS << 7 ) );
    FLAGS |= Parite[ RegC ];
    if ( CBIndex )
        POKE8( core, RegHL, RegC );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_0A( core_crocods_t *core )   /* RRC D */
{
    FLAGS = ( UBYTE )( RegD & FLAG_C );
    RegD = ( UBYTE )( ( RegD >> 1 ) | ( FLAGS << 7 ) );
    FLAGS |= Parite[ RegD ];
    if ( CBIndex )
        POKE8( core, RegHL, RegD );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_0B( core_crocods_t *core )   /* RRC E */
{
    FLAGS = ( UBYTE )( RegE & FLAG_C );
    RegE = ( UBYTE )( ( RegE >> 1 ) | ( FLAGS << 7 ) );
    FLAGS |= Parite[ RegE ];
    if ( CBIndex )
        POKE8( core, RegHL, RegE );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_0C( core_crocods_t *core )   /* RRC H */
{
    FLAGS = ( UBYTE )( RegH & FLAG_C );
    RegH = ( UBYTE )( ( RegH >> 1 ) | ( FLAGS << 7 ) );
    FLAGS |= Parite[ RegH ];
    if ( CBIndex )
        POKE8( core, RegHL, RegH );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_0D( core_crocods_t *core )   /* RRC L */
{
    FLAGS = ( UBYTE )( RegL & FLAG_C );
    RegL = ( UBYTE )( ( RegL >> 1 ) | ( FLAGS << 7 ) );
    FLAGS |= Parite[ RegL ];
    if ( CBIndex )
        POKE8( core, RegHL, RegL );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_0E( core_crocods_t *core )   /* RRC (HL) */
{
    int hl = PEEK8( core, RegHL );
    FLAGS = ( UBYTE )( hl & FLAG_C );
    POKE8( core, RegHL, ( UBYTE )( hl = ( hl >> 1 ) | ( FLAGS << 7 ) ) );
    FLAGS |= Parite[ hl ];
    return( 4 /* 4 NOPs */ );
}


static int CB_0F( core_crocods_t *core )   /* RRC A */
{
    FLAGS = ( UBYTE )( RegA & FLAG_C );
    RegA = ( UBYTE )( ( RegA >> 1 ) | ( FLAGS << 7 ) );
    FLAGS |= Parite[ RegA ];
    if ( CBIndex )
        POKE8( core, RegHL, RegA );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_10( core_crocods_t *core )   /* RL B */
{
    int i = RegB << 1;
    RegB = ( UBYTE )( i | ( FLAGS & FLAG_C ) );
    FLAGS = ( UBYTE )( ( i >> 8 ) | Parite[ RegB ] );
    if ( CBIndex )
        POKE8( core, RegHL, RegB );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_11( core_crocods_t *core )   /* RL C */
{
    int i = RegC << 1;
    RegC = ( UBYTE )( i | ( FLAGS & FLAG_C ) );
    FLAGS = ( UBYTE )( ( i >> 8 ) | Parite[ RegC ] );
    if ( CBIndex )
        POKE8( core, RegHL, RegC );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_12( core_crocods_t *core )   /* RL D */
{
    int i = RegD << 1;
    RegD = ( UBYTE )( i | ( FLAGS & FLAG_C ) );
    FLAGS = ( UBYTE )( ( i >> 8 ) | Parite[ RegD ] );
    if ( CBIndex )
        POKE8( core, RegHL, RegD );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_13( core_crocods_t *core )   /* RL E */
{
    int i = RegE << 1;
    RegE = ( UBYTE )( i | ( FLAGS & FLAG_C ) );
    FLAGS = ( UBYTE )( ( i >> 8 ) | Parite[ RegE ] );
    if ( CBIndex )
        POKE8( core, RegHL, RegE );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_14( core_crocods_t *core )   /* RL H */
{
    int i = RegH << 1;
    RegH = ( UBYTE )( i | ( FLAGS & FLAG_C ) );
    FLAGS = ( UBYTE )( ( i >> 8 ) |Parite[ RegH ] );
    if ( CBIndex )
        POKE8( core, RegHL, RegH );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_15( core_crocods_t *core )   /* RL L */
{
    int i = RegL << 1;
    RegL = ( UBYTE )( i | ( FLAGS & FLAG_C ) );
    FLAGS = ( UBYTE )( ( i >> 8 ) | Parite[ RegL ] );
    if ( CBIndex )
        POKE8( core, RegHL, RegL );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_16( core_crocods_t *core )   /* RL (HL) */
{
    int hl = PEEK8( core, RegHL );
    int i = hl << 1;
    POKE8( core, RegHL, ( UBYTE )( hl = i | ( FLAGS & FLAG_C ) ) );
    FLAGS = ( UBYTE )( ( i >> 8 ) | Parite[ hl & 0xFF ] );
    return( 4 /* 4 NOPs */ );
}


static int CB_17( core_crocods_t *core )   /* RL A */
{
    int i = RegA << 1;
    RegA = ( UBYTE )( i | ( FLAGS & FLAG_C ) );
    FLAGS = ( UBYTE )( ( i >> 8 ) | Parite[ RegA ] );
    if ( CBIndex )
        POKE8( core, RegHL, RegA );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_18( core_crocods_t *core )   /* RR B */
{
    UBYTE i = ( UBYTE )( ( RegB >> 1 ) | ( FLAGS << 7 ) );
    FLAGS = ( UBYTE )( ( RegB & FLAG_C ) | Parite[ i ] );
    RegB = i;
    if ( CBIndex )
        POKE8( core, RegHL, RegB );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_19( core_crocods_t *core )   /* RR C */
{
    UBYTE i = ( UBYTE )( ( RegC >> 1 ) | ( FLAGS << 7 ) );
    FLAGS = ( UBYTE )( ( RegC & FLAG_C ) | Parite[ i ] );
    RegC = i;
    if ( CBIndex )
        POKE8( core, RegHL, RegC );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_1A( core_crocods_t *core )   /* RR D */
{
    UBYTE i = ( UBYTE )( ( RegD >> 1 ) | ( FLAGS << 7 ) );
    FLAGS = ( UBYTE )( ( RegD & FLAG_C ) | Parite[ i ] );
    RegD = i;
    if ( CBIndex )
        POKE8( core, RegHL, RegD );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_1B( core_crocods_t *core )   /* RR E */
{
    UBYTE i = ( UBYTE )( ( RegE >> 1 ) | ( FLAGS << 7 ) );
    FLAGS = ( UBYTE )( ( RegE & FLAG_C ) | Parite[ i ] );
    RegE = i;
    if ( CBIndex )
        POKE8( core, RegHL, RegE );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_1C( core_crocods_t *core )   /* RR H */
{
    UBYTE i = ( UBYTE )( ( RegH >> 1 ) | ( FLAGS << 7 ) );
    FLAGS = ( UBYTE )( ( RegH & FLAG_C ) | Parite[ i ] );
    RegH = i;
    if ( CBIndex )
        POKE8( core, RegHL, RegH );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_1D( core_crocods_t *core )   /* RR L */
{
    UBYTE i = ( UBYTE )( ( RegL >> 1 ) | ( FLAGS << 7 ) );
    FLAGS = ( UBYTE )( ( RegL & FLAG_C ) | Parite[ i ] );
    RegL = i;
    if ( CBIndex )
        POKE8( core, RegHL, RegL );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_1E( core_crocods_t *core )   /* RR (HL) */
{
    int hl = PEEK8( core, RegHL );
    UBYTE i = ( UBYTE )( ( hl >> 1 ) | ( FLAGS << 7 ) );
    FLAGS = ( UBYTE )( ( hl & FLAG_C ) | Parite[ i ] );
    POKE8( core, RegHL, ( UBYTE )i );
    return( 4 /* 4 NOPs */ );
}


static int CB_1F( core_crocods_t *core )   /* RR A */
{
    UBYTE i = ( UBYTE )( ( RegA >> 1 ) | ( FLAGS << 7 ) );
    FLAGS = ( UBYTE )( ( RegA & FLAG_C ) | Parite[ i ] );
    RegA = i;
    if ( CBIndex )
        POKE8( core, RegHL, RegA );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_20( core_crocods_t *core )   /* SLA B */
{
    FLAGS = ( UBYTE )( RegB >> 7 );
    RegB = ( UBYTE )( RegB << 1 );
    FLAGS |= Parite[ RegB ];
    if ( CBIndex )
        POKE8( core, RegHL, RegB );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_21( core_crocods_t *core )   /* SLA C */
{
    FLAGS = ( UBYTE )( RegC >> 7 );
    RegC = ( UBYTE )( RegC << 1 );
    FLAGS |= Parite[ RegC ];
    if ( CBIndex )
        POKE8( core, RegHL, RegC );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_22( core_crocods_t *core )   /* SLA D */
{
    FLAGS = ( UBYTE )( RegD >> 7 );
    RegD = ( UBYTE )( RegD << 1 );
    FLAGS |= Parite[ RegD ];
    if ( CBIndex )
        POKE8( core, RegHL, RegD );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_23( core_crocods_t *core )   /* SLA E */
{
    FLAGS = ( UBYTE )( RegE >> 7 );
    RegE = ( UBYTE )( RegE << 1 );
    FLAGS |= Parite[ RegE ];
    if ( CBIndex )
        POKE8( core, RegHL, RegE );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_24( core_crocods_t *core )   /* SLA H */
{
    FLAGS = ( UBYTE )( RegH >> 7 );
    RegH = ( UBYTE )( RegH << 1 );
    FLAGS |= Parite[ RegH ];
    if ( CBIndex )
        POKE8( core, RegHL, RegH );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_25( core_crocods_t *core )   /* SLA L */
{
    FLAGS = ( UBYTE )( RegL >> 7 );
    RegL = ( UBYTE )( RegL << 1 );
    FLAGS |= Parite[ RegL ];
    if ( CBIndex )
        POKE8( core, RegHL, RegL );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_26( core_crocods_t *core )   /* SLA (HL) */
{
    int hl = PEEK8( core, RegHL );
    FLAGS = ( UBYTE )( hl >> 7 );
    POKE8( core, RegHL, ( UBYTE )( hl = hl << 1 ) );
    FLAGS |= Parite[ hl ];
    return( 4 /* 4 NOPs */ );
}


static int CB_27( core_crocods_t *core )   /* SLA A */
{
    FLAGS = ( UBYTE )( RegA >> 7 );
    RegA = ( UBYTE )( RegA << 1 );
    FLAGS |= Parite[ RegA ];
    if ( CBIndex )
        POKE8( core, RegHL, RegA );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_28( core_crocods_t *core )   /* SRA B */
{
    FLAGS = ( UBYTE )( RegB & FLAG_C );
    RegB = ( UBYTE )( ( RegB >> 1 ) | ( RegB & FLAG_S ) );
    FLAGS |= Parite[ RegB ];
    if ( CBIndex )
        POKE8( core, RegHL, RegB );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_29( core_crocods_t *core )   /* SRA C */
{
    FLAGS = ( UBYTE )( RegC & FLAG_C );
    RegC = ( UBYTE )( ( RegC >> 1 ) | ( RegC & FLAG_S ) );
    FLAGS |= Parite[ RegC ];
    if ( CBIndex )
        POKE8( core, RegHL, RegC );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_2A( core_crocods_t *core )   /* SRA D */
{
    FLAGS = ( UBYTE )( RegD & FLAG_C );
    RegD = ( UBYTE )( ( RegD >> 1 ) | ( RegD & FLAG_S ) );
    FLAGS |= Parite[ RegD ];
    if ( CBIndex )
        POKE8( core, RegHL, RegD );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_2B( core_crocods_t *core )   /* SRA E */
{
    FLAGS = ( UBYTE )( RegE & FLAG_C );
    RegE = ( UBYTE )( ( RegE >> 1 ) | ( RegE & FLAG_S ) );
    FLAGS |= Parite[ RegE ];
    if ( CBIndex )
        POKE8( core, RegHL, RegE );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_2C( core_crocods_t *core )   /* SRA H */
{
    FLAGS = ( UBYTE )( RegH & FLAG_C );
    RegH = ( UBYTE )( ( RegH >> 1 ) | ( RegH & FLAG_S ) );
    FLAGS |= Parite[ RegH ];
    if ( CBIndex )
        POKE8( core, RegHL, RegH );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_2D( core_crocods_t *core )   /* SRA L */
{
    FLAGS = ( UBYTE )( RegL & FLAG_C );
    RegL = ( UBYTE )( ( RegL >> 1 ) | ( RegL & FLAG_S ) );
    FLAGS |= Parite[ RegL ];
    if ( CBIndex )
        POKE8( core, RegHL, RegL );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_2E( core_crocods_t *core )   /* SRA (HL) */
{
    int hl = PEEK8( core, RegHL );
    FLAGS = ( UBYTE )( hl & FLAG_C );
    POKE8( core, RegHL, ( UBYTE )( hl = ( hl >> 1 ) | ( hl & FLAG_S ) ) );
    FLAGS |= Parite[ hl ];
    return( 4 /* 4 NOPs */ );
}


static int CB_2F( core_crocods_t *core )   /* SRA A */
{
    FLAGS = ( UBYTE )( RegA & FLAG_C );
    RegA = ( UBYTE )( ( RegA >> 1 ) | ( RegA & FLAG_S ) );
    FLAGS |= Parite[ RegA ];
    if ( CBIndex )
        POKE8( core, RegHL, RegA );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_30( core_crocods_t *core )   /* SLL B */
{
    FLAGS = ( UBYTE )( RegB >> 7 );
    RegB = ( UBYTE )( ( RegB << 1 ) | 1 );
    FLAGS |= Parite[ RegB ];
    if ( CBIndex )
        POKE8( core, RegHL, RegB );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_31( core_crocods_t *core )   /* SLL C */
{
    FLAGS = ( UBYTE )( RegC >> 7 );
    RegC = ( UBYTE )( ( RegC << 1 ) | 1 );
    FLAGS |= Parite[ RegC ];
    if ( CBIndex )
        POKE8( core, RegHL, RegC );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_32( core_crocods_t *core )   /* SLL D */
{
    FLAGS = ( UBYTE )( RegD >> 7 );
    RegD = ( UBYTE )( ( RegD << 1 ) | 1 );
    FLAGS |= Parite[ RegD ];
    if ( CBIndex )
        POKE8( core, RegHL, RegD );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_33( core_crocods_t *core )   /* SLL E */
{
    FLAGS = ( UBYTE )( RegE >> 7 );
    RegE = ( UBYTE )( ( RegE << 1 ) | 1 );
    FLAGS |= Parite[ RegE ];
    if ( CBIndex )
        POKE8( core, RegHL, RegE );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_34( core_crocods_t *core )   /* SLL H */
{
    FLAGS = ( UBYTE )( RegH >> 7 );
    RegH = ( UBYTE )( ( RegH << 1 ) | 1 );
    FLAGS |= Parite[ RegH ];
    if ( CBIndex )
        POKE8( core, RegHL, RegH );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_35( core_crocods_t *core )   /* SLL L */
{
    FLAGS = ( UBYTE )( RegL >> 7 );
    RegL = ( UBYTE )( ( RegL << 1 ) | 1 );
    FLAGS |= Parite[ RegL ];
    if ( CBIndex )
        POKE8( core, RegHL, RegL );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_36( core_crocods_t *core )   /* SLL (HL) */
{
    int hl = PEEK8( core, RegHL );
    FLAGS = ( UBYTE )( hl >> 7 );
    POKE8( core, RegHL, ( UBYTE )( ( hl = hl << 1 ) | 1 ) );
    FLAGS |= Parite[ hl ];
    return( 4 /* 4 NOPs */ );
}


static int CB_37( core_crocods_t *core )   /* SLL A */
{
    FLAGS = ( UBYTE )( RegA >> 7 );
    RegA = ( UBYTE )( ( RegA << 1 ) | 1);
    FLAGS |= Parite[ RegA ];
    if ( CBIndex )
        POKE8( core, RegHL, RegA );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_38( core_crocods_t *core )   /* SRL B */
{
    FLAGS = ( UBYTE )( RegB & FLAG_C );
    RegB = ( UBYTE )( RegB >> 1 );
    FLAGS |= Parite[ RegB ];
    if ( CBIndex )
        POKE8( core, RegHL, RegB );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_39( core_crocods_t *core )   /* SRL C */
{
    FLAGS = ( UBYTE )( RegC & FLAG_C );
    RegC = ( UBYTE )( RegC >> 1 );
    FLAGS |= Parite[ RegC ];
    if ( CBIndex )
        POKE8( core, RegHL, RegC );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_3A( core_crocods_t *core )   /* SRL D */
{
    FLAGS = ( UBYTE )( RegD & FLAG_C );
    RegD = ( UBYTE )( RegD >> 1 );
    FLAGS |= Parite[ RegD ];
    if ( CBIndex )
        POKE8( core, RegHL, RegD );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_3B( core_crocods_t *core )   /* SRL E */
{
    FLAGS = ( UBYTE )( RegE & FLAG_C );
    RegE = ( UBYTE )( RegE >> 1 );
    FLAGS |= Parite[ RegE ];
    if ( CBIndex )
        POKE8( core, RegHL, RegE );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_3C( core_crocods_t *core )   /* SRL H */
{
    FLAGS = ( UBYTE )( RegH & FLAG_C );
    RegH = ( UBYTE )( RegH >> 1 );
    FLAGS |= Parite[ RegH ];
    if ( CBIndex )
        POKE8( core, RegHL, RegH );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_3D( core_crocods_t *core )   /* SRL L */
{
    FLAGS = ( UBYTE )( RegL & FLAG_C );
    RegL = ( UBYTE )( RegL >> 1 );
    FLAGS |= Parite[ RegL ];
    if ( CBIndex )
        POKE8( core, RegHL, RegL );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_3E( core_crocods_t *core )   /* SRL (HL) */
{
    int hl = PEEK8( core, RegHL );
    FLAGS = ( UBYTE )( hl & FLAG_C );
    POKE8( core, RegHL, ( UBYTE )( hl = hl >> 1 ) );
    FLAGS |= Parite[ hl ];
    return( 4 /* 4 NOPs */ );
}


static int CB_3F( core_crocods_t *core )   /* SRL A */
{
    FLAGS = ( UBYTE )( RegA & FLAG_C );
    RegA = ( UBYTE )( RegA >> 1 );
    FLAGS |= Parite[ RegA ];
    if ( CBIndex )
        POKE8( core, RegHL, RegA );
    
    return( 2 /* 2 NOPs */ );
}


static int CB_40( core_crocods_t *core )      /* BIT 0, B */
{
    Bit( core, RegB, BIT0 );
    return( 2 /* 2 NOPs */ );
}


static int CB_41( core_crocods_t *core )      /* BIT 0, C */
{
    Bit( core, RegC, BIT0 );
    return( 2 /* 2 NOPs */ );
}


static int CB_42( core_crocods_t *core )      /* BIT 0, D */
{
    Bit( core, RegD, BIT0 );
    return( 2 /* 2 NOPs */ );
}


static int CB_43( core_crocods_t *core )      /* BIT 0, E */
{
    Bit( core, RegE, BIT0 );
    return( 2 /* 2 NOPs */ );
}


static int CB_44( core_crocods_t *core )      /* BIT 0, H */
{
    Bit( core, RegH, BIT0 );
    return( 2 /* 2 NOPs */ );
}


static int CB_45( core_crocods_t *core )      /* BIT 0, L */
{
    Bit( core, RegL, BIT0 );
    return( 2 /* 2 NOPs */ );
}


static int CB_46( core_crocods_t *core )      /* BIT 0, (HL) */
{
    Bit( core, ( UBYTE )PEEK8( core, RegHL ), BIT0 );
    return( 3 /* 3 NOPs */ );
}


static int CB_47( core_crocods_t *core )      /* BIT 0, A */
{
    Bit( core, RegA, BIT0 );
    return( 2 /* 2 NOPs */ );
}


static int CB_48( core_crocods_t *core )      /* BIT 1, B */
{
    Bit( core, RegB, BIT1 );
    return( 2 /* 2 NOPs */ );
}


static int CB_49( core_crocods_t *core )      /* BIT 1, C */
{
    Bit( core, RegC, BIT1 );
    return( 2 /* 2 NOPs */ );
}


static int CB_4A( core_crocods_t *core )      /* BIT 1, D */
{
    Bit( core, RegD, BIT1 );
    return( 2 /* 2 NOPs */ );
}


static int CB_4B( core_crocods_t *core )      /* BIT 1, E */
{
    Bit( core, RegE, BIT1 );
    return( 2 /* 2 NOPs */ );
}


static int CB_4C( core_crocods_t *core )      /* BIT 1, H */
{
    Bit( core, RegH, BIT1 );
    return( 2 /* 2 NOPs */ );
}


static int CB_4D( core_crocods_t *core )      /* BIT 1, L */
{
    Bit( core, RegL, BIT1 );
    return( 2 /* 2 NOPs */ );
}


static int CB_4E( core_crocods_t *core )      /* BIT 1, (HL) */
{
    Bit( core, ( UBYTE )PEEK8( core, RegHL ), BIT1 );
    return( 3 /* 3 NOPs */ );
}


static int CB_4F( core_crocods_t *core )      /* BIT 1, A */
{
    Bit( core, RegA, BIT1 );
    return( 2 /* 2 NOPs */ );
}


static int CB_50( core_crocods_t *core )      /* BIT 2, B */
{
    Bit( core, RegB, BIT2 );
    return( 2 /* 2 NOPs */ );
}


static int CB_51( core_crocods_t *core )      /* BIT 2, C */
{
    Bit( core, RegC, BIT2 );
    return( 2 /* 2 NOPs */ );
}


static int CB_52( core_crocods_t *core )      /* BIT 2, D */
{
    Bit( core, RegD, BIT2 );
    return( 2 /* 2 NOPs */ );
}


static int CB_53( core_crocods_t *core )      /* BIT 2, E */
{
    Bit( core, RegE, BIT2 );
    return( 2 /* 2 NOPs */ );
}


static int CB_54( core_crocods_t *core )      /* BIT 2, H */
{
    Bit( core, RegH, BIT2 );
    return( 2 /* 2 NOPs */ );
}


static int CB_55( core_crocods_t *core )      /* BIT 2, L */
{
    Bit( core, RegL, BIT2 );
    return( 2 /* 2 NOPs */ );
}


static int CB_56( core_crocods_t *core )      /* BIT 2, (HL) */
{
    Bit( core, ( UBYTE )PEEK8( core, RegHL ), BIT2 );
    return( 3 /* 3 NOPs */ );
}


static int CB_57( core_crocods_t *core )      /* BIT 2, A */
{
    Bit( core, RegA, BIT2 );
    return( 2 /* 2 NOPs */ );
}


static int CB_58( core_crocods_t *core )      /* BIT 3, B */
{
    Bit( core, RegB, BIT3 );
    return( 2 /* 2 NOPs */ );
}


static int CB_59( core_crocods_t *core )      /* BIT 3, C */
{
    Bit( core, RegC, BIT3 );
    return( 2 /* 2 NOPs */ );
}


static int CB_5A( core_crocods_t *core )      /* BIT 3, D */
{
    Bit( core, RegD, BIT3 );
    return( 2 /* 2 NOPs */ );
}


static int CB_5B( core_crocods_t *core )      /* BIT 3, E */
{
    Bit( core, RegE, BIT3 );
    return( 2 /* 2 NOPs */ );
}


static int CB_5C( core_crocods_t *core )      /* BIT 3, H */
{
    Bit( core, RegH, BIT3 );
    return( 2 /* 2 NOPs */ );
}


static int CB_5D( core_crocods_t *core )      /* BIT 3, L */
{
    Bit( core, RegL, BIT3 );
    return( 2 /* 2 NOPs */ );
}


static int CB_5E( core_crocods_t *core )      /* BIT 3, (HL) */
{
    Bit( core, ( UBYTE )PEEK8( core, RegHL ), BIT3 );
    return( 3 /* 3 NOPs */ );
}


static int CB_5F( core_crocods_t *core )      /* BIT 3, A */
{
    Bit( core, RegA, BIT3 );
    return( 2 /* 2 NOPs */ );
}


static int CB_60( core_crocods_t *core )      /* BIT 4, B */
{
    Bit( core, RegB, BIT4 );
    return( 2 /* 2 NOPs */ );
}


static int CB_61( core_crocods_t *core )      /* BIT 4, C */
{
    Bit( core, RegC, BIT4 );
    return( 2 /* 2 NOPs */ );
}


static int CB_62( core_crocods_t *core )      /* BIT 4, D */
{
    Bit( core, RegD, BIT4 );
    return( 2 /* 2 NOPs */ );
}


static int CB_63( core_crocods_t *core )      /* BIT 4, E */
{
    Bit( core, RegE, BIT4 );
    return( 2 /* 2 NOPs */ );
}


static int CB_64( core_crocods_t *core )      /* BIT 4, H */
{
    Bit( core, RegH, BIT4 );
    return( 2 /* 2 NOPs */ );
}


static int CB_65( core_crocods_t *core )      /* BIT 4, L */
{
    Bit( core, RegL, BIT4 );
    return( 2 /* 2 NOPs */ );
}


static int CB_66( core_crocods_t *core )      /* BIT 4, (HL) */
{
    Bit( core, ( UBYTE )PEEK8( core, RegHL ), BIT4 );
    return( 3 /* 3 NOPs */ );
}


static int CB_67( core_crocods_t *core )      /* BIT 4, A */
{
    Bit( core, RegA, BIT4 );
    return( 2 /* 2 NOPs */ );
}


static int CB_68( core_crocods_t *core )      /* BIT 5, B */
{
    Bit( core, RegB, BIT5 );
    return( 2 /* 2 NOPs */ );
}


static int CB_69( core_crocods_t *core )      /* BIT 5, C */
{
    Bit( core, RegC, BIT5 );
    return( 2 /* 2 NOPs */ );
}


static int CB_6A( core_crocods_t *core )      /* BIT 5, D */
{
    Bit( core, RegD, BIT5 );
    return( 2 /* 2 NOPs */ );
}


static int CB_6B( core_crocods_t *core )      /* BIT 5, E */
{
    Bit( core, RegE, BIT5 );
    return( 2 /* 2 NOPs */ );
}


static int CB_6C( core_crocods_t *core )      /* BIT 5, H */
{
    Bit( core, RegH, BIT5 );
    return( 2 /* 2 NOPs */ );
}


static int CB_6D( core_crocods_t *core )      /* BIT 5, L */
{
    Bit( core, RegL, BIT5 );
    return( 2 /* 2 NOPs */ );
}


static int CB_6E( core_crocods_t *core )      /* BIT 5, (HL) */
{
    Bit( core, ( UBYTE )PEEK8( core, RegHL ), BIT5 );
    return( 3 /* 3 NOPs */ );
}


static int CB_6F( core_crocods_t *core )      /* BIT 5, A */
{
    Bit( core, RegA, BIT5 );
    return( 2 /* 2 NOPs */ );
}


static int CB_70( core_crocods_t *core )      /* BIT 6, B */
{
    Bit( core, RegB, BIT6 );
    return( 2 /* 2 NOPs */ );
}


static int CB_71( core_crocods_t *core )      /* BIT 6, C */
{
    Bit( core, RegC, BIT6 );
    return( 2 /* 2 NOPs */ );
}


static int CB_72( core_crocods_t *core )      /* BIT 6, D */
{
    Bit( core, RegD, BIT6 );
    return( 2 /* 2 NOPs */ );
}


static int CB_73( core_crocods_t *core )      /* BIT 6, E */
{
    Bit( core, RegE, BIT6 );
    return( 2 /* 2 NOPs */ );
}


static int CB_74( core_crocods_t *core )      /* BIT 6, H */
{
    Bit( core, RegH, BIT6 );
    return( 2 /* 2 NOPs */ );
}


static int CB_75( core_crocods_t *core )      /* BIT 6, L */
{
    Bit( core, RegL, BIT6 );
    return( 2 /* 2 NOPs */ );
}


static int CB_76( core_crocods_t *core )      /* BIT 6, (HL) */
{
    Bit( core, ( UBYTE )PEEK8( core, RegHL ), BIT6 );
    return( 3 /* 3 NOPs */ );
}


static int CB_77( core_crocods_t *core )      /* BIT 6, A */
{
    Bit( core, RegA, BIT6 );
    return( 2 /* 2 NOPs */ );
}


static int CB_78( core_crocods_t *core )      /* BIT 7, B */
{
    Bit( core, RegB, BIT7 );
    return( 2 /* 2 NOPs */ );
}


static int CB_79( core_crocods_t *core )      /* BIT 7, C */
{
    Bit( core, RegC, BIT7 );
    return( 2 /* 2 NOPs */ );
}


static int CB_7A( core_crocods_t *core )      /* BIT 7, D */
{
    Bit( core, RegD, BIT7 );
    return( 2 /* 2 NOPs */ );
}


static int CB_7B( core_crocods_t *core )      /* BIT 7, E */
{
    Bit( core, RegE, BIT7 );
    return( 2 /* 2 NOPs */ );
}


static int CB_7C( core_crocods_t *core )      /* BIT 7, H */
{
    Bit( core, RegH, BIT7 );
    return( 2 /* 2 NOPs */ );
}


static int CB_7D( core_crocods_t *core )      /* BIT 7, L */
{
    Bit( core, RegL, BIT7 );
    return( 2 /* 2 NOPs */ );
}


static int CB_7E( core_crocods_t *core )      /* BIT 7, (HL) */
{
    Bit( core, ( UBYTE )PEEK8( core, RegHL ), BIT7 );
    return( 3 /* 3 NOPs */ );
}


static int CB_7F( core_crocods_t *core )      /* BIT 7, A */
{
    Bit( core, RegA, BIT7 );
    return( 2 /* 2 NOPs */ );
}


static int CB_80( core_crocods_t *core )      /* RES 0, B */
{
    RegB &= ~BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_81( core_crocods_t *core )      /* RES 0, C */
{
    RegC &= ~BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_82( core_crocods_t *core )      /* RES 0, D */
{
    RegD &= ~BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_83( core_crocods_t *core )      /* RES 0, E */
{
    RegE &= ~BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_84( core_crocods_t *core )      /* RES 0, H */
{
    RegH &= ~BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_85( core_crocods_t *core )      /* RES 0, L */
{
    RegL &= ~BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_86( core_crocods_t *core )      /* RES 0, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) & ~BIT0 ) );
    return( 4 /* 4 NOPs */ );
}


static int CB_87( core_crocods_t *core )      /* RES 0, A */
{
    RegA &= ~BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_88( core_crocods_t *core )      /* RES 1, B */
{
    RegB &= ~BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_89( core_crocods_t *core )      /* RES 1, C */
{
    RegC &= ~BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_8A( core_crocods_t *core )      /* RES 1, D */
{
    RegD &= ~BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_8B( core_crocods_t *core )      /* RES 1, E */
{
    RegE &= ~BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_8C( core_crocods_t *core )      /* RES 1, H */
{
    RegH &= ~BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_8D( core_crocods_t *core )      /* RES 1, L */
{
    RegL &= ~BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_8E( core_crocods_t *core )      /* RES 1, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) & ~BIT1 ) );
    return( 4 /* 4 NOPs */ );
}


static int CB_8F( core_crocods_t *core )      /* RES 1, A */
{
    RegA &= ~BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_90( core_crocods_t *core )      /* RES 2, B */
{
    RegB &= ~BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_91( core_crocods_t *core )      /* RES 2, C */
{
    RegC &= ~BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_92( core_crocods_t *core )      /* RES 2, D */
{
    RegD &= ~BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_93( core_crocods_t *core )      /* RES 2, E */
{
    RegE &= ~BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_94( core_crocods_t *core )      /* RES 2, H */
{
    RegH &= ~BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_95( core_crocods_t *core )      /* RES 2, L */
{
    RegL &= ~BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_96( core_crocods_t *core )      /* RES 2, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) & ~BIT2 ) );
    return( 4 /* 4 NOPs */ );
}


static int CB_97( core_crocods_t *core )      /* RES 2, A */
{
    RegA &= ~BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_98( core_crocods_t *core )      /* RES 3, B */
{
    RegB &= ~BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_99( core_crocods_t *core )      /* RES 3, C */
{
    RegC &= ~BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_9A( core_crocods_t *core )      /* RES 3, D */
{
    RegD &= ~BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_9B( core_crocods_t *core )      /* RES 3, E */
{
    RegE &= ~BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_9C( core_crocods_t *core )      /* RES 3, H */
{
    RegH &= ~BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_9D( core_crocods_t *core )      /* RES 3, L */
{
    RegL &= ~BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_9E( core_crocods_t *core )      /* RES 3, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) & ~BIT3 ) );
    return( 4 /* 4 NOPs */ );
}


static int CB_9F( core_crocods_t *core )      /* RES 3, A */
{
    RegA &= ~BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_A0( core_crocods_t *core )      /* RES 4, B */
{
    RegB &= ~BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_A1( core_crocods_t *core )      /* RES 4, C */
{
    RegC &= ~BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_A2( core_crocods_t *core )      /* RES 4, D */
{
    RegD &= ~BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_A3( core_crocods_t *core )      /* RES 4, E */
{
    RegE &= ~BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_A4( core_crocods_t *core )      /* RES 4, H */
{
    RegH &= ~BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_A5( core_crocods_t *core )      /* RES 4, L */
{
    RegL &= ~BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_A6( core_crocods_t *core )      /* RES 4, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) & ~BIT4 ) );
    return( 4 /* 4 NOPs */ );
}


static int CB_A7( core_crocods_t *core )      /* RES 4, A */
{
    RegA &= ~BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_A8( core_crocods_t *core )      /* RES 5, B */
{
    RegB &= ~BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_A9( core_crocods_t *core )      /* RES 5, C */
{
    RegC &= ~BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_AA( core_crocods_t *core )      /* RES 5, D */
{
    RegD &= ~BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_AB( core_crocods_t *core )      /* RES 5, E */
{
    RegE &= ~BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_AC( core_crocods_t *core )      /* RES 5, H */
{
    RegH &= ~BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_AD( core_crocods_t *core )      /* RES 5, L */
{
    RegL &= ~BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_AE( core_crocods_t *core )      /* RES 5, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) & ~BIT5 ) );
    return( 4 /* 4 NOPs */ );
}


static int CB_AF( core_crocods_t *core )      /* RES 5, A */
{
    RegA &= ~BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_B0( core_crocods_t *core )      /* RES 6, B */
{
    RegB &= ~BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_B1( core_crocods_t *core )      /* RES 6, C */
{
    RegC &= ~BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_B2( core_crocods_t *core )      /* RES 6, D */
{
    RegD &= ~BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_B3( core_crocods_t *core )      /* RES 6, E */
{
    RegE &= ~BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_B4( core_crocods_t *core )      /* RES 6, H */
{
    RegH &= ~BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_B5( core_crocods_t *core )      /* RES 6, L */
{
    RegL &= ~BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_B6( core_crocods_t *core )      /* RES 6, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) & ~BIT6 ) );
    return( 4 /* 4 NOPs */ );
}


static int CB_B7( core_crocods_t *core )      /* RES 6, A */
{
    RegA &= ~BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_B8( core_crocods_t *core )      /* RES 7, B */
{
    RegB &= ~BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_B9( core_crocods_t *core )      /* RES 7, C */
{
    RegC &= ~BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_BA( core_crocods_t *core )      /* RES 7, D */
{
    RegD &= ~BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_BB( core_crocods_t *core )      /* RES 7, E */
{
    RegE &= ~BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_BC( core_crocods_t *core )      /* RES 7, H */
{
    RegH &= ~BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_BD( core_crocods_t *core )      /* RES 7, L */
{
    RegL &= ~BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_BE( core_crocods_t *core )      /* RES 7, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) & ~BIT7 ) );
    return( 4 /* 4 NOPs */ );
}


static int CB_BF( core_crocods_t *core )      /* RES 7, A */
{
    RegA &= ~BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_C0( core_crocods_t *core )      /* SET 0, B */
{
    RegB |= BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_C1( core_crocods_t *core )      /* SET 0, C */
{
    RegC |= BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_C2( core_crocods_t *core )      /* SET 0, D */
{
    RegD |= BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_C3( core_crocods_t *core )      /* SET 0, E */
{
    RegE |= BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_C4( core_crocods_t *core )      /* SET 0, H */
{
    RegH |= BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_C5( core_crocods_t *core )      /* SET 0, L */
{
    RegL |= BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_C6( core_crocods_t *core )      /* SET 0, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) | BIT0 ) );
    return( 3 /* 3 NOPs */ );
}


static int CB_C7( core_crocods_t *core )      /* SET 0, A */
{
    RegA |= BIT0;
    return( 2 /* 2 NOPs */ );
}


static int CB_C8( core_crocods_t *core )      /* SET 1, B */
{
    RegB |= BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_C9( core_crocods_t *core )      /* SET 1, C */
{
    RegC |= BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_CA( core_crocods_t *core )      /* SET 1, D */
{
    RegD |= BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_CB( core_crocods_t *core )      /* SET 1, E */
{
    RegE |= BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_CC( core_crocods_t *core )      /* SET 1, H */
{
    RegH |= BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_CD( core_crocods_t *core )      /* SET 1, L */
{
    RegL |= BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_CE( core_crocods_t *core )      /* SET 1, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) | BIT1 ) );
    return( 3 /* 3 NOPs */ );
}


static int CB_CF( core_crocods_t *core )      /* SET 1, A */
{
    RegA |= BIT1;
    return( 2 /* 2 NOPs */ );
}


static int CB_D0( core_crocods_t *core )      /* SET 2, B */
{
    RegB |= BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_D1( core_crocods_t *core )      /* SET 2, C */
{
    RegC |= BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_D2( core_crocods_t *core )      /* SET 2, D */
{
    RegD |= BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_D3( core_crocods_t *core )      /* SET 2, E */
{
    RegE |= BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_D4( core_crocods_t *core )      /* SET 2, H */
{
    RegH |= BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_D5( core_crocods_t *core )      /* SET 2, L */
{
    RegL |= BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_D6( core_crocods_t *core )      /* SET 2, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) | BIT2 ) );
    return( 3 /* 3 NOPs */ );
}


static int CB_D7( core_crocods_t *core )      /* SET 2, A */
{
    RegA |= BIT2;
    return( 2 /* 2 NOPs */ );
}


static int CB_D8( core_crocods_t *core )      /* SET 3, B */
{
    RegB |= BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_D9( core_crocods_t *core )      /* SET 3, C */
{
    RegC |= BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_DA( core_crocods_t *core )      /* SET 3, D */
{
    RegD |= BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_DB( core_crocods_t *core )      /* SET 3, E */
{
    RegE |= BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_DC( core_crocods_t *core )      /* SET 3, H */
{
    RegH |= BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_DD( core_crocods_t *core )      /* SET 3, L */
{
    RegL |= BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_DE( core_crocods_t *core )      /* SET 3, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) | BIT3 ) );
    return( 3 /* 3 NOPs */ );
}


static int CB_DF( core_crocods_t *core )      /* SET 3, A */
{
    RegA |= BIT3;
    return( 2 /* 2 NOPs */ );
}


static int CB_E0( core_crocods_t *core )      /* SET 4, B */
{
    RegB |= BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_E1( core_crocods_t *core )      /* SET 4, C */
{
    RegC |= BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_E2( core_crocods_t *core )      /* SET 4, D */
{
    RegD |= BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_E3( core_crocods_t *core )      /* SET 4, E */
{
    RegE |= BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_E4( core_crocods_t *core )      /* SET 4, H */
{
    RegH |= BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_E5( core_crocods_t *core )      /* SET 4, L */
{
    RegL |= BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_E6( core_crocods_t *core )      /* SET 4, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) | BIT4 ) );
    return( 3 /* 3 NOPs */ );
}


static int CB_E7( core_crocods_t *core )      /* SET 4, A */
{
    RegA |= BIT4;
    return( 2 /* 2 NOPs */ );
}


static int CB_E8( core_crocods_t *core )      /* SET 5, B */
{
    RegB |= BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_E9( core_crocods_t *core )      /* SET 5, C */
{
    RegC |= BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_EA( core_crocods_t *core )      /* SET 5, D */
{
    RegD |= BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_EB( core_crocods_t *core )      /* SET 5, E */
{
    RegE |= BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_EC( core_crocods_t *core )      /* SET 5, H */
{
    RegH |= BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_ED( core_crocods_t *core )      /* SET 5, L */
{
    RegL |= BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_EE( core_crocods_t *core )      /* SET 5, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) | BIT5 ) );
    return( 3 /* 3 NOPs */ );
}


static int CB_EF( core_crocods_t *core )      /* SET 5, A */
{
    RegA |= BIT5;
    return( 2 /* 2 NOPs */ );
}


static int CB_F0( core_crocods_t *core )      /* SET 6, B */
{
    RegB |= BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_F1( core_crocods_t *core )      /* SET 6, C */
{
    RegC |= BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_F2( core_crocods_t *core )      /* SET 6, D */
{
    RegD |= BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_F3( core_crocods_t *core )      /* SET 6, E */
{
    RegE |= BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_F4( core_crocods_t *core )      /* SET 6, H */
{
    RegH |= BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_F5( core_crocods_t *core )      /* SET 6, L */
{
    RegL |= BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_F6( core_crocods_t *core )      /* SET 6, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) | BIT6 ) );
    return( 3 /* 3 NOPs */ );
}


static int CB_F7( core_crocods_t *core )      /* SET 6, A */
{
    RegA |= BIT6;
    return( 2 /* 2 NOPs */ );
}


static int CB_F8( core_crocods_t *core )      /* SET 7, B */
{
    RegB |= BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_F9( core_crocods_t *core )      /* SET 7, C */
{
    RegC |= BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_FA( core_crocods_t *core )      /* SET 7, D */
{
    RegD |= BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_FB( core_crocods_t *core )      /* SET 7, E */
{
    RegE |= BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_FC( core_crocods_t *core )      /* SET 7, H */
{
    RegH |= BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_FD( core_crocods_t *core )      /* SET 7, L */
{
    RegL |= BIT7;
    return( 2 /* 2 NOPs */ );
}


static int CB_FE( core_crocods_t *core )      /* SET 7, ( HL ) */
{
    POKE8( core, RegHL, ( UBYTE )( PEEK8( core, RegHL ) | BIT7 ) );
    return( 3 /* 3 NOPs */ );
}


static int CB_FF( core_crocods_t *core )      /* SET 7, A */
{
    RegA |= BIT7;
    return( 2 /* 2 NOPs */ );
}


/************
 * OPCODE ED *
 ************/


/********************************************************* !NAME! **************
 * Nom : ed___
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Exécutée sur rencontre d'une instruction ED XX inconnue
 *
 * Résultat    : 0
 *
 ********************************************************** !0! ****************/
static int ed___( core_crocods_t *core )
{
    printf(  "Instruction ED%02X a l'adresse %04X rencontree."
           , PEEK8( core, ( USHORT )( RegPC - 1 ) )
           , RegPC - 2
           );
    
    return( 2 );
}


static int ED_40( core_crocods_t *core ) /* IN B, ( C ) */
{
    
    RegB = ( UBYTE )ReadPort( core, RegBC );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegB ] );
    return( 4 /* 4 NOPs */ );
}


static int ED_41( core_crocods_t *core ) /* OUT ( C ), B */
{
    WritePort( core, RegBC, RegB );
    return( 4 /* 4 NOPs */ );
}


static int ED_42( core_crocods_t *core ) /* SBC HL, BC */
{
    SBC_R16( core, RegBC );
    return( 4 /* 4 NOPs */ );
}


static int ED_43( core_crocods_t *core ) /* LD ( nnnn ), BC */
{
    POKE16( core, PEEK16( core, RegPC ), RegBC );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int ED_44( core_crocods_t *core ) /* NEG */
{
    int t = - RegA;
    
    FLAGS = ( UBYTE )( ( RegA & t & 0x80 ? FLAG_V : 0 )
                      | FLAG_N
                      | - ( t >> 8 )
                      | ( t & FLAG_S )
                      | ( ( t & 0xFF ) ? 0 : FLAG_Z )
                      | ( ( RegA ^ t ) & FLAG_H )
                      );
    RegA = ( UBYTE )t;
    return( 2 /* 2 NOPs */ );
}


static int ED_45( core_crocods_t *core ) /* RETN */
{
    core->Z80.IFF1 = core->Z80.IFF2;
#ifdef HACK_IRQ
    VerifyIRQ(core);
#endif
    
    RegPC = PEEK16( core, RegSP );
    RegSP += 2;
    return( 4 /* 4 NOPs */ );
}


static int ED_46( core_crocods_t *core ) /* IM 0 */
{
    core->Z80.InterruptMode = 0;
    ed___(core);
    return( 2 /* 2 NOPs */ );
}


static int ED_47( core_crocods_t *core ) /* LD I, A */
{
    RegI = RegA;
    return( 3 /* 3 NOPs */ );
}


static int ED_48( core_crocods_t *core ) /* IN C, ( C ) */
{
    RegC = ( UBYTE )ReadPort( core, RegBC );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegC ] );
    return( 4 /* 4 NOPs */ );
}


static int ED_49( core_crocods_t *core ) /* OUT ( C ), C */
{
    WritePort( core, RegBC, RegC );
    return( 4 /* 4 NOPs */ );
}


static int ED_4A( core_crocods_t *core ) /* ADC HL, BC */
{
    ADC_R16( core, RegBC );
    return( 5 /* 5 NOPs */ );
}


static int ED_4B( core_crocods_t *core ) /* LD BC, ( nnnn ) */
{
    RegBC = PEEK16( core, PEEK16( core, RegPC ) );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int ED_4D( core_crocods_t *core ) /* RETI */
{
    core->Z80.IFF1 = core->Z80.IFF2;
#ifdef HACK_IRQ
    VerifyIRQ(core);
#endif
    RegPC = PEEK16( core, RegSP );
    RegSP += 2;
    return( 4 /* 4 NOPs */ );
}


static int ED_4F( core_crocods_t *core ) /* LD R, A */
{
    RegR = RegA;
    return( 3 /* 3 NOPs */ );
}


static int ED_50( core_crocods_t *core ) /* IN D, ( C ) */
{
    RegD = ( UBYTE )ReadPort( core, RegBC );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegD ] );
    return( 4 /* 4 NOPs */ );
}


static int ED_51( core_crocods_t *core ) /* OUT ( C ), D */
{
    WritePort( core, RegBC, RegD );
    return( 4 /* 4 NOPs */ );
}


static int ED_52( core_crocods_t *core ) /* SBC HL, DE */
{
    SBC_R16( core, RegDE );
    return( 4 /* 4 NOPs */ );
}


static int ED_53( core_crocods_t *core ) /* LD ( nnnn ), DE */
{
    POKE16( core, PEEK16( core, RegPC ), RegDE );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int ED_56( core_crocods_t *core ) /* IM 1 */
{
    core->Z80.InterruptMode = 1;
    return( 2 /* 2 NOPs */ );
}


static int ED_57( core_crocods_t *core ) /* LD A, I */
{
    RegA = RegI;
    FLAGS =  (UBYTE)((FLAGS & FLAG_C)
                     | (RegA ? (RegA & FLAG_S) : FLAG_Z)
                     | (RegA & (BIT5|BIT3))
                     | (core->Z80.IFF2 & 1 ? FLAG_V : 0)
                     );
    
    return( 3 /* 3 NOPs */ );
}


static int ED_58( core_crocods_t *core ) /* IN E, ( C ) */
{
    RegE = ( UBYTE )ReadPort( core, RegBC );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegE ] );
    return( 4 /* 4 NOPs */ );
}


static int ED_59( core_crocods_t *core ) /* OUT ( C ), E */
{
    WritePort( core, RegBC, RegE );
    return( 4 /* 4 NOPs */ );
}


static int ED_5A( core_crocods_t *core ) /* ADC HL, DE */
{
    ADC_R16( core, RegDE );
    return( 4 /* 4 NOPs */ );
}


static int ED_5B( core_crocods_t *core ) /* LD DE, ( nnnn ) */
{
    RegDE = PEEK16( core, PEEK16( core, RegPC ) );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int ED_5E( core_crocods_t *core ) /* IM 2 */
{
    core->Z80.InterruptMode = 2;
    return( 2 /* 2 NOPs */ );
}


static int ED_5F( core_crocods_t *core ) /* LD A, R */
{
    RegA = RegR;
    FLAGS =  (UBYTE)((FLAGS & FLAG_C)
                     | (RegA ? (RegA & FLAG_S) : FLAG_Z)
                     | (RegA & (BIT5|BIT3))
                     | (core->Z80.IFF2 & 1 ? FLAG_V : 0)
                     );
    
    return( 3 /* 3 NOPs */ );
}


static int ED_60( core_crocods_t *core ) /* IN H, ( C ) */
{
    RegH = ( UBYTE )ReadPort( core, RegBC );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegH ] );
    return( 4 /* 4 NOPs */ );
}


static int ED_61( core_crocods_t *core ) /* OUT ( C ), H */
{
    WritePort( core, RegBC, RegH );
    return( 4 /* 4 NOPs */ );
}


static int ED_62( core_crocods_t *core ) /* SBC HL, HL */
{
    SBC_R16( core, RegHL );
    return( 4 /* 4 NOPs */ );
}


static int ED_63( core_crocods_t *core ) /* LD ( nnnn ), HL */
{
    POKE16( core, PEEK16( core, RegPC ), RegHL );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int ED_67( core_crocods_t *core ) /* RRD */
{
    int a = RegA;
    int hl = PEEK8( core, RegHL );
    
    RegA = ( UBYTE )( ( a & 0xF0 ) | ( hl & 0xF ) );
    POKE8( core, RegHL, ( UBYTE )( ( hl >> 4 ) | ( a << 4 ) ) );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegA ] );
    return( 5 /* 5 NOPs */ );
}


static int ED_68( core_crocods_t *core ) /* IN L, ( C ) */
{
    RegL = ( UBYTE )ReadPort( core, RegBC );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegL ] );
    return( 4 /* 4 NOPs */ );
}


static int ED_69( core_crocods_t *core ) /* OUT ( C ), L */
{
    WritePort( core, RegBC, RegL );
    return( 4 /* 4 NOPs */ );
}


static int ED_6A( core_crocods_t *core ) /* ADC HL, HL */
{
    ADC_R16( core, RegHL );
    return( 4 /* 4 NOPs */ );
}


static int ED_6B( core_crocods_t *core ) /* LD HL, ( nnnn ) */
{
    RegHL = PEEK16( core, PEEK16( core, RegPC ) );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int ED_6F( core_crocods_t *core ) /* RLD */
{
    int a = RegA;
    int hl = PEEK8( core, RegHL );
    
    RegA = ( UBYTE )( ( a & 0xF0 ) | ( hl >> 4 ) );
    POKE8( core, RegHL, ( UBYTE )( ( hl << 4 ) | ( a & 0xF ) ) );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegA ] );
    return( 5 /* 5 NOPs */ );
}


static int ED_70( core_crocods_t *core ) /* IN F, ( C ) */
{
    ReadPort( core, RegBC );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegL ] );
    ed___(core);
    return( 4 /* 4 NOPs */ );
}


static int ED_71( core_crocods_t *core ) /* OUT ( C ), 0 */
{
    WritePort( core, RegBC, 0 );
    return( 4 /* 4 NOPs */ );
}


static int ED_72( core_crocods_t *core ) /* SBC HL, SP */
{
    SBC_R16( core, RegSP );
    return( 4 /* 4 NOPs */ );
}


static int ED_73( core_crocods_t *core ) /* LD ( nnnn ), SP */
{
    POKE16( core, PEEK16( core, RegPC ), RegSP );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int ED_78( core_crocods_t *core ) /* IN A, ( C ) */
{
    RegA = ( UBYTE )ReadPort( core, RegBC );
    FLAGS = ( UBYTE )( ( FLAGS & FLAG_C ) | Parite[ RegA ] );
    return( 4 /* 4 NOPs */ );
}


static int ED_79( core_crocods_t *core ) /* OUT ( C ), A */
{
    WritePort( core, RegBC, RegA );
    return( 4 /* 4 NOPs */ );
}


static int ED_7A( core_crocods_t *core ) /* ADC HL, SP */
{
    ADC_R16( core, RegSP );
    return( 4 /* 4 NOPs */ );
}


static int ED_7B( core_crocods_t *core ) /* LD SP, ( nnnn ) */
{
    RegSP = PEEK16( core, PEEK16( core, RegPC ) );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int ED_A0( core_crocods_t *core ) /* LDI */
{
    POKE8( core, RegDE++, ( UBYTE )PEEK8( core, RegHL++ ) );
    FLAGS &= ~FLAG_H & ~FLAG_V & ~FLAG_N;
    if ( --RegBC )
        FLAGS |= FLAG_V;
    
    return( 5 /* 5 NOPs */ );
}


static int ED_A1( core_crocods_t *core ) /* CPI */
{
    FLAGS &= ~FLAG_Z & ~FLAG_V;
    
    if ( RegA == PEEK8( core, RegHL++ ) )
        FLAGS |= FLAG_Z;
    
    if ( --RegBC )
        FLAGS |= FLAG_V;
    
    FLAGS |= FLAG_N;
    return( 5 /* 5 NOPs */ );
}


static int ED_A2( core_crocods_t *core ) /* INI */
{
    POKE8( core, RegHL++, ( UBYTE )ReadPort( core, RegBC ) );
    /* #### A vérifier : flags #### */
    FLAGS = FLAG_N;
    if ( --RegB )
        FLAGS &= ~FLAG_Z;
    else
        FLAGS |= FLAG_Z;
    
    return( 5 /* 5 NOPs */ );
}


static int ED_A3( core_crocods_t *core ) /* OUTI */
{
    FLAGS = FLAG_N;
    /* #### A vérifier : flags #### */
    if ( --RegB )
        FLAGS &= ~FLAG_Z;
    else
        FLAGS |= FLAG_Z;
    
    WritePort( core, RegBC, PEEK8( core, RegHL++ ) );
    return( 5 /* 5 NOPs */ );
}


static int ED_A8( core_crocods_t *core ) /* LDD */
{
    POKE8( core, RegDE--, ( UBYTE )PEEK8( core, RegHL-- ) );
    FLAGS &= ~FLAG_H & ~FLAG_V & ~FLAG_N;
    if ( --RegBC )
        FLAGS |= FLAG_V;
    
    return( 5 /* 5 NOPs */ );
}


static int ED_A9( core_crocods_t *core ) /* CPD */
{
    FLAGS &= ~FLAG_Z & ~FLAG_V;
    
    if ( RegA == PEEK8( core, RegHL-- ) )
        FLAGS |= FLAG_Z;
    
    if ( --RegBC )
        FLAGS |= FLAG_V;
    
    FLAGS |= FLAG_N;
    return( 5 /* 5 NOPs */ );
}


static int ED_AA( core_crocods_t *core ) /* IND */
{
    FLAGS = FLAG_N;
    POKE8( core, RegHL--, ( UBYTE )ReadPort( core, RegBC ) );
    /* #### A vérifier : flags #### */
    if ( --RegB )
        FLAGS &= ~FLAG_Z;
    else
        FLAGS |= FLAG_Z;
    
    return( 5 /* 5 NOPs */ );
}


static int ED_AB( core_crocods_t *core ) /* OUTD */
{
    /* #### A vérifier : flags #### */
    FLAGS = FLAG_N;
    if ( --RegB )
        FLAGS &= ~FLAG_Z;
    else
        FLAGS |= FLAG_Z;
    
    WritePort( core, RegBC, PEEK8( core, RegHL-- ) );
    return( 5 /* 5 NOPs */ );
}


#ifdef HACK_LDIR
static int ED_B0( core_crocods_t *core ) /* LDIR */
{
    int r = 5;
    r+=RegBC;
    
    do {
        POKEPEEK8( RegDE++, RegHL++ );
        FLAGS &= ~FLAG_H & ~FLAG_V & ~FLAG_N;
        RegBC--;
    } while (RegBC!=0);
    
    return( r );
}
#else
static int ED_B0( core_crocods_t *core ) /* LDIR */
{
    int r = 5;
    
    POKE8( core, RegDE++, ( UBYTE )PEEK8( core, RegHL++ ) );
    FLAGS &= ~FLAG_H & ~FLAG_V & ~FLAG_N;
    if (--RegBC) {
        RegPC -= 2;
        FLAGS |= FLAG_V;
        r++;
    }
    
    return( r );
}
#endif


static int ED_B1( core_crocods_t *core ) /* CPIR */
{
    int r = 5;
    UBYTE i = ( UBYTE )PEEK8( core, RegHL++ );
    UBYTE tmp = ( UBYTE )( RegA - i );
    RegBC--;
    FLAGS = ( UBYTE )( FLAG_N
                      | ( FLAGS & FLAG_C )
                      | ( tmp & FLAG_S )
                      | ( tmp ? 0 : FLAG_Z )
                      | ( ( RegA ^ i ^ tmp ) &FLAG_H )
                      | ( RegBC ? FLAG_V : 0 )
                      );
    if ( RegBC && tmp )
    {
        r++;
        RegPC -= 2;
        
    }
    return( r );
}


static int ED_B2( core_crocods_t *core ) /* INIR */
{
    return( ed___(core) );
}


static int ED_B3( core_crocods_t *core ) /* OTIR */
{
    return( ed___(core) );
}


static int ED_B8( core_crocods_t *core ) /* LDDR */
{
    int r = 5;
    POKE8( core, RegDE--, ( UBYTE )PEEK8( core, RegHL-- ) );
    FLAGS &= ~FLAG_H & ~FLAG_V & ~FLAG_N;
    if ( --RegBC )
    {
        FLAGS |= FLAG_V;
        r++;
        RegPC -= 2;
    }
    return( r );
}


static int ED_B9( core_crocods_t *core ) /* CPDR */
{
    int r = 5;
    UBYTE i = ( UBYTE )PEEK8( core, RegHL-- );
    UBYTE tmp = ( UBYTE )( RegA - i );
    RegBC--;
    FLAGS = ( UBYTE )( FLAG_N
                      | ( FLAGS & FLAG_C )
                      | ( tmp & FLAG_S )
                      | ( tmp ? 0 : FLAG_Z )
                      | ( ( RegA ^ i ^ tmp ) &FLAG_H )
                      | ( RegBC ? FLAG_V : 0 )
                      );
    if ( RegBC && tmp )
    {
        r++;
        RegPC -= 2;
        
    }
    return( r );
}


static int ED_BA( core_crocods_t *core ) /* INDR */
{
    return( ed___(core) );
}


static int ED_BB( core_crocods_t *core ) /* OTDR */
{
    return( ed___(core) );
}


/************
 * OPCODE DD *
 ************/


/********************************************************* !NAME! **************
 * Nom : dd___
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Exécutée sur rencontre d'une instruction DD XX inconnue
 *
 * Résultat    : 0
 *
 ********************************************************** !0! ****************/
static int dd___( core_crocods_t *core )
{
    printf(  "Instruction DD%02X a l'adresse %04X rencontree."
           , PEEK8( core, ( USHORT )( RegPC - 1 ) )
           , RegPC - 2
           );
    
    RegPC++;
    return( 2 );
}


static USHORT GetIXdd( core_crocods_t *core )
{
    return( USHORT )( RegIX + ( signed char )PEEK8( core, RegPC++ ) );
}


static int DD_09( core_crocods_t *core ) /* ADD IX, BC */
{
    ADD_R16( core, &RegIX, RegBC );
    return( 4 /* 4 NOPs */ );
}


static int DD_19( core_crocods_t *core ) /* ADD IX, DE */
{
    ADD_R16( core, &RegIX, RegDE );
    return( 4 /* 4 NOPs */ );
}


static int DD_21( core_crocods_t *core ) /* LD IX, nnnn */
{
    RegIX = PEEK16( core, RegPC );
    RegPC += 2;
    return( 4 /* 4 NOPs */ );
}


static int DD_22( core_crocods_t *core ) /* LD ( nnnn ), IX */
{
    POKE16( core, PEEK16( core, RegPC ), RegIX );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int DD_23( core_crocods_t *core ) /* INC IX */
{
    ++RegIX;
    return( 3 /* 3 NOPs */ );
}


static int DD_24( core_crocods_t *core ) /* INC IXh */
{
    FLAG_INC( core, ++RegIXH );
    return( 2 /* 2 NOPs */ );
}


static int DD_25( core_crocods_t *core ) /* DEC IXh */
{
    FLAG_DEC( core, --RegIXH );
    return( 2 /* 2 NOPs */ );
}


static int DD_26( core_crocods_t *core ) /* LD IXh, n */
{
    RegIXH = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 3 /* 3 NOPs */ );
}


static int DD_29( core_crocods_t *core ) /* ADD IX, IX */
{
    ADD_R16( core, &RegIX, RegIX );
    return( 4 /* 4 NOPs */ );
}


static int DD_2A( core_crocods_t *core ) /* LD IX, ( nnnn ) */
{
    RegIX = PEEK16( core, PEEK16( core, RegPC ) );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int DD_2B( core_crocods_t *core ) /* DEC IX */
{
    --RegIX;
    return( 3 /* 3 NOPs */ );
}


static int DD_2C( core_crocods_t *core ) /* INC IXl */
{
    FLAG_INC( core, ++RegIXL );
    return( 2 /* 2 NOPs */ );
}


static int DD_2D( core_crocods_t *core ) /* DEC IXl */
{
    FLAG_DEC( core, --RegIXL );
    return( 2 /* 2 NOPs */ );
}


static int DD_2E( core_crocods_t *core ) /* LD IXl, n */
{
    RegIXL = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 3 /* 3 NOPs */ );
}


static int DD_34( core_crocods_t *core ) /* INC (IX+n) */
{
    USHORT ofs = GetIXdd(core);
    UBYTE r = ( UBYTE )PEEK8( core, ofs );
    FLAG_INC( core, ++r );
    POKE8( core, ofs, r );
    return( 6 /* 6 NOPs */ );
}


static int DD_35( core_crocods_t *core ) /* DEC (IX+n) */
{
    USHORT ofs = GetIXdd(core);
    UBYTE r = ( UBYTE )PEEK8( core, ofs );
    FLAG_DEC( core, --r );
    POKE8( core, ofs, r );
    return( 6 /* 6 NOPs */ );
}


static int DD_36( core_crocods_t *core ) /* LD (IX+d), n */
{
    USHORT ofs = GetIXdd(core);
    POKE8( core, ofs, ( UBYTE )PEEK8( core, RegPC ) );
    RegPC++;
    return( 6 /* 6 NOPs */ );
}


static int DD_39( core_crocods_t *core ) /* ADD IX, SP */
{
    ADD_R16( core, &RegIX, RegSP );
    return( 4 /* 4 NOPs */ );
}


static int DD_44( core_crocods_t *core ) /* LD B, IXh */
{
    RegB = RegIXH;
    return( 2 /* 2 NOPs */ );
}


static int DD_45( core_crocods_t *core ) /* LD B, IXl */
{
    RegB = RegIXL;
    return( 2 /* 2 NOPs */ );
}


static int DD_46( core_crocods_t *core ) /* LD B, (IX+d) */
{
    RegB = ( UBYTE )PEEK8( core, GetIXdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int DD_4C( core_crocods_t *core ) /* LD C, IXh */
{
    RegC = RegIXH;
    return( 2 /* 2 NOPs */ );
}


static int DD_4D( core_crocods_t *core ) /* LD C, IXl */
{
    RegC = RegIXL;
    return( 2 /* 2 NOPs */ );
}


static int DD_4E( core_crocods_t *core ) /* LD C, (IX+d) */
{
    RegC = ( UBYTE )PEEK8( core, GetIXdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int DD_54( core_crocods_t *core ) /* LD D, IXh */
{
    RegD = RegIXH;
    return( 2 /* 2 NOPs */ );
}


static int DD_55( core_crocods_t *core ) /* LD D, IXl */
{
    RegD = RegIXL;
    return( 2 /* 2 NOPs */ );
}


static int DD_56( core_crocods_t *core ) /* LD D, (IX+d) */
{
    RegD = ( UBYTE )PEEK8( core, GetIXdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int DD_5C( core_crocods_t *core ) /* LD E, IXh */
{
    RegE = RegIXH;
    return( 2 /* 2 NOPs */ );
}


static int DD_5D( core_crocods_t *core ) /* LD E, IXl */
{
    RegE = RegIXL;
    return( 2 /* 2 NOPs */ );
}


static int DD_5E( core_crocods_t *core ) /* LD E, (IX+d) */
{
    RegE = ( UBYTE )PEEK8( core, GetIXdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int DD_60( core_crocods_t *core ) /* LD IXh, B */
{
    RegIXH = RegB;
    return( 2 /* 2 NOPs */ );
}


static int DD_61( core_crocods_t *core ) /* LD IXh, C */
{
    RegIXH = RegC;
    return( 2 /* 2 NOPs */ );
}


static int DD_62( core_crocods_t *core ) /* LD IXh, D */
{
    RegIXH = RegD;
    return( 2 /* 2 NOPs */ );
}


static int DD_63( core_crocods_t *core ) /* LD IXh, E */
{
    RegIXH = RegE;
    return( 2 /* 2 NOPs */ );
}


static int DD_65( core_crocods_t *core ) /* LD IXh, IXl */
{
    RegIXH = RegIXL;
    return( 2 /* 2 NOPs */ );
}


static int DD_66( core_crocods_t *core ) /* LD H, (IX+d) */
{
    RegH = ( UBYTE )PEEK8( core, GetIXdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int DD_67( core_crocods_t *core ) /* LD IXh, A */
{
    RegIXH = RegA;
    return( 2 /* 2 NOPs */ );
}


static int DD_68( core_crocods_t *core ) /* LD IXl, B */
{
    RegIXL = RegB;
    return( 2 /* 2 NOPs */ );
}


static int DD_69( core_crocods_t *core ) /* LD IXl, C */
{
    RegIXL = RegC;
    return( 2 /* 2 NOPs */ );
}


static int DD_6A( core_crocods_t *core ) /* LD IXl, D */
{
    RegIXL = RegD;
    return( 2 /* 2 NOPs */ );
}


static int DD_6B( core_crocods_t *core ) /* LD IXl, E */
{
    RegIXL = RegE;
    return( 2 /* 2 NOPs */ );
}


static int DD_6C( core_crocods_t *core ) /* LD IXl, IXH */
{
    RegIXL = RegIXH;
    return( 2 /* 2 NOPs */ );
}


static int DD_6E( core_crocods_t *core ) /* LD L, (IX+d) */
{
    RegL = ( UBYTE )PEEK8( core, GetIXdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int DD_6F( core_crocods_t *core ) /* LD IXl, A */
{
    RegIXL = RegA;
    return( 2 /* 2 NOPs */ );
}


static int DD_70( core_crocods_t *core ) /* LD (IX+d), B */
{
    POKE8( core, GetIXdd(core), RegB );
    return( 5 /* 5 NOPs */ );
}


static int DD_71( core_crocods_t *core ) /* LD (IX+d), C */
{
    POKE8( core, GetIXdd(core), RegC );
    return( 5 /* 5 NOPs */ );
}


static int DD_72( core_crocods_t *core ) /* LD (IX+d), D */
{
    POKE8( core, GetIXdd(core), RegD );
    return( 5 /* 5 NOPs */ );
}


static int DD_73( core_crocods_t *core ) /* LD (IX+d), E */
{
    POKE8( core, GetIXdd(core), RegE );
    return( 5 /* 5 NOPs */ );
}


static int DD_74( core_crocods_t *core ) /* LD (IX+d), H */
{
    POKE8( core, GetIXdd(core), RegH );
    return( 5 /* 5 NOPs */ );
}


static int DD_75( core_crocods_t *core ) /* LD (IX+d), L */
{
    POKE8( core, GetIXdd(core), RegL );
    return( 5 /* 5 NOPs */ );
}


static int DD_77( core_crocods_t *core ) /* LD (IX+d), A */
{
    POKE8( core, GetIXdd(core), RegA );
    return( 5 /* 5 NOPs */ );
}


static int DD_7C( core_crocods_t *core ) /* LD A, IXh */
{
    RegA = RegIXH;
    return( 2 /* 2 NOPs */ );
}


static int DD_7D( core_crocods_t *core ) /* LD A, IXl */
{
    RegA = RegIXL;
    return( 2 /* 2 NOPs */ );
}


static int DD_7E( core_crocods_t *core ) /* LD A, (IX+d) */
{
    RegA = ( UBYTE )PEEK8( core, GetIXdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int DD_84( core_crocods_t *core ) /* ADD A, IXh */
{
    ADD_R8( core, RegIXH );
    return( 2 /* 2 NOPs */ );
}


static int DD_85( core_crocods_t *core ) /* ADD A, IXl */
{
    ADD_R8( core, RegIXL );
    return( 2 /* 2 NOPs */ );
}


static int DD_86( core_crocods_t *core ) /* ADD A, (IX+n) */
{
    ADD_R8( core, PEEK8( core, GetIXdd(core) ) );
    return( 5 /* 5 NOPs */ );
}


static int DD_8C( core_crocods_t *core ) /* ADC A, IXh */
{
    ADC_R8( core, RegIXH );
    return( 2 /* 2 NOPs */ );
}


static int DD_8D( core_crocods_t *core ) /* ADC A, IXl */
{
    ADC_R8( core, RegIXL );
    return( 2 /* 2 NOPs */ );
}


static int DD_8E( core_crocods_t *core ) /* ADC A, (IX+n) */
{
    ADC_R8( core, PEEK8( core, GetIXdd(core)  ) );
    return( 5 /* 5 NOPs */ );
}


static int DD_94( core_crocods_t *core ) /* SUB IXh */
{
    SUB_R8( core, RegIXH );
    return( 2 /* 2 NOPs */ );
}


static int DD_95( core_crocods_t *core ) /* SUB IXl */
{
    SUB_R8( core, RegIXL );
    return( 2 /* 2 NOPs */ );
}


static int DD_96( core_crocods_t *core ) /* SUB (IX+n) */
{
    SUB_R8( core, PEEK8( core, GetIXdd(core) ) );
    return( 5 /* 5 NOPs */ );
}


static int DD_9C( core_crocods_t *core ) /* SBC A, IXh */
{
    SBC_R8( core, RegIXH );
    return( 2 /* 2 NOPs */ );
}


static int DD_9D( core_crocods_t *core ) /* SBC A, IXl */
{
    SBC_R8( core, RegIXL );
    return( 2 /* 2 NOPs */ );
}


static int DD_9E( core_crocods_t *core ) /* SBC A, (IX+n) */
{
    SBC_R8( core, PEEK8( core, GetIXdd(core) ) );
    return( 5 /* 5 NOPs */ );
}


static int DD_A4( core_crocods_t *core ) /* AND IXh */
{
    RegA &= RegIXH;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 2 /* 2 NOPs */ );
}


static int DD_A5( core_crocods_t *core ) /* AND IXl */
{
    RegA &= RegIXL;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 2 /* 2 NOPs */ );
}


static int DD_A6( core_crocods_t *core ) /* AND (IX+n) */
{
    RegA &= PEEK8( core, GetIXdd(core) );
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 5 /* 5 NOPs */ );
}


static int DD_AC( core_crocods_t *core ) /* XOR IXh */
{
    RegA ^= RegIXH;
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int DD_AD( core_crocods_t *core ) /* XOR IXl */
{
    RegA ^= RegIXL;
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int DD_AE( core_crocods_t *core ) /* XOR (IX+n) */
{
    RegA ^= PEEK8( core, GetIXdd(core) );
    FLAGS = Parite[ RegA ];
    return( 5 /* 5 NOPs */ );
}


static int DD_B4( core_crocods_t *core ) /* OR IXh */
{
    RegA |= RegIXH;
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int DD_B5( core_crocods_t *core ) /* OR IXl */
{
    RegA |= RegIXL;
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int DD_B6( core_crocods_t *core ) /* OR (IX+n) */
{
    RegA |= PEEK8( core, GetIXdd(core) );
    FLAGS = Parite[ RegA ];
    return( 5 /* 5 NOPs */ );
}


static int DD_BC( core_crocods_t *core ) /* CP IXh */
{
    CP_R8( core, RegIXH );
    return( 2 /* 2 NOPs */ );
}


static int DD_BD( core_crocods_t *core ) /* CP IXl */
{
    CP_R8( core, RegIXL );
    return( 2 /* 2 NOPs */ );
}


static int DD_BE( core_crocods_t *core ) /* CP (IX+n) */
{
    CP_R8( core, PEEK8( core, GetIXdd(core) ) );
    return( 5 /* 5 NOPs */ );
}


static int DD_CB( core_crocods_t *core ) /* special code CB */
{
    int r, tmp = RegHL;
    RegHL = ( USHORT )GetIXdd(core);
    CBIndex = 1;
    r = tabCB[ PEEK8( core, RegPC++ ) ](core);
    CBIndex = 0;
    RegHL = ( USHORT )tmp;
    return( r + 4 ); // ### a vérifier...
}


static int DD_E1( core_crocods_t *core ) /* POP IX */
{
    RegIX = PEEK16( core, RegSP );
    RegSP += 2;
    return( 5 /* 5 NOPs */ );
}


static int DD_E3( core_crocods_t *core ) /* EX (SP), IX */
{
    USHORT a = PEEK16( core, RegSP );
    POKE16( core, RegSP, RegIX );
    RegIX = a;
    return( 7 /* 7 NOPs */ );
}


static int DD_E5( core_crocods_t *core ) /* PUSH IX */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegIX );
    return( 5 /* 5 NOPs */ );
}


static int DD_E9( core_crocods_t *core ) /* JP (IX) */
{
    RegPC = RegIX;
    return( 2 /* 2 NOPs */ );
}


static int DD_F9( core_crocods_t *core ) /* LD SP, IX */
{
    RegSP = RegIX;
    return( 3 /* 3 NOPs */ );
}


static int DD_FD( core_crocods_t *core ) /* special DD_FD */
{
    // Se comporte commme un simple FD
    RegR = ( UBYTE )( ( ( RegR + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ) );
    return( 1 + tabIY[ PEEK8( core, RegPC++ ) ](core) ); // ### A vérifier
}



/************
 * OPCODE FD *
 ************/


/********************************************************* !NAME! **************
 * Nom : fd___
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Exécutée sur rencontre d'une instruction FD XX inconnue
 *
 * Résultat    : 0
 *
 ********************************************************** !0! ****************/
static int fd___( core_crocods_t *core )
{
    printf( "Instruction FD%02X a l'adresse %04X rencontree.\n"
           , PEEK8( core, ( USHORT )( RegPC - 1 ) )
           , RegPC - 2
           );
    
    RegPC++;
    return( 2 );
}


static USHORT GetIYdd( core_crocods_t *core )
{
    return( USHORT )( RegIY + ( signed char )PEEK8( core, RegPC++ ) );
}


static int FD_09( core_crocods_t *core ) /* ADD IY, BC */
{
    ADD_R16( core, &RegIY, RegBC );
    return( 4 /* 4 NOPs */ );
}


static int FD_19( core_crocods_t *core ) /* ADD IY, DE */
{
    ADD_R16( core, &RegIY, RegDE );
    return( 4 /* 4 NOPs */ );
}


static int FD_21( core_crocods_t *core ) /* LD IY, nnnn */
{
    RegIY = PEEK16( core, RegPC );
    RegPC += 2;
    return( 4 /* 4 NOPs */ );
}


static int FD_22( core_crocods_t *core ) /* LD ( nnnn ), IY */
{
    POKE16( core, PEEK16( core, RegPC ), RegIY );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int FD_23( core_crocods_t *core ) /* INC IY */
{
    ++RegIY;
    return( 3 /* 3 NOPs */ );
}


static int FD_24( core_crocods_t *core ) /* INC IYh */
{
    FLAG_INC( core, ++RegIYH );
    return( 2 /* 2 NOPs */ );
}


static int FD_25( core_crocods_t *core ) /* DEC IYh */
{
    FLAG_DEC( core, --RegIYH );
    return( 2 /* 2 NOPs */ );
}


static int FD_26( core_crocods_t *core ) /* LD IYh, n */
{
    RegIYH = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 3 /* 3 NOPs */ );
}


static int FD_29( core_crocods_t *core ) /* ADD IY, IY */
{
    ADD_R16( core, &RegIY, RegIY );
    return( 4 /* 4 NOPs */ );
}


static int FD_2A( core_crocods_t *core ) /* LD IY, ( nnnn ) */
{
    RegIY = PEEK16( core, PEEK16( core, RegPC ) );
    RegPC += 2;
    return( 6 /* 6 NOPs */ );
}


static int FD_2B( core_crocods_t *core ) /* DEC IY */
{
    --RegIY;
    return( 3 /* 3 NOPs */ );
}


static int FD_2C( core_crocods_t *core ) /* INC IYl */
{
    FLAG_INC( core, ++RegIYL );
    return( 2 /* 2 NOPs */ );
}


static int FD_2D( core_crocods_t *core ) /* DEC IYl */
{
    FLAG_DEC( core, --RegIYL );
    return( 2 /* 2 NOPs */ );
}


static int FD_2E( core_crocods_t *core ) /* LD IYl, n */
{
    RegIYL = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 3 /* 3 NOPs */ );
}


static int FD_34( core_crocods_t *core ) /* INC (IY+n) */
{
    USHORT ofs = GetIYdd(core);
    UBYTE r = ( UBYTE )PEEK8( core, ofs );
    FLAG_INC( core, ++r );
    POKE8( core, ofs, r );
    return( 6 /* 6 NOPs */ );
}


static int FD_35( core_crocods_t *core ) /* DEC (IY+n) */
{
    USHORT ofs = GetIYdd(core);
    UBYTE r = ( UBYTE )PEEK8( core, ofs );
    FLAG_DEC( core, --r );
    POKE8( core, ofs, r );
    return( 6 /* 6 NOPs */ );
}


static int FD_36( core_crocods_t *core ) /* LD (IY+d), n */
{
    USHORT ofs = GetIYdd(core);
    POKE8( core, ofs, ( UBYTE )PEEK8( core, RegPC ) );
    RegPC++;
    return( 6 /* 6 NOPs */ );
}


static int FD_39( core_crocods_t *core ) /* ADD IY, SP */
{
    ADD_R16( core, &RegIY, RegSP );
    return( 4 /* 4 NOPs */ );
}


static int FD_44( core_crocods_t *core ) /* LD B, IYh */
{
    RegB = RegIYH;
    return( 2 /* 2 NOPs */ );
}


static int FD_45( core_crocods_t *core ) /* LD B, IYl */
{
    RegB = RegIYL;
    return( 2 /* 2 NOPs */ );
}


static int FD_46( core_crocods_t *core ) /* LD B, (IY+d) */
{
    RegB = ( UBYTE )PEEK8( core, GetIYdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int FD_4C( core_crocods_t *core ) /* LD C, IYh */
{
    RegC = RegIYH;
    return( 2 /* 2 NOPs */ );
}


static int FD_4D( core_crocods_t *core ) /* LD C, IYl */
{
    RegC = RegIYL;
    return( 2 /* 2 NOPs */ );
}


static int FD_4E( core_crocods_t *core ) /* LD C, (IY+d) */
{
    RegC = ( UBYTE )PEEK8( core, GetIYdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int FD_54( core_crocods_t *core ) /* LD D, IYh */
{
    RegD = RegIYH;
    return( 2 /* 2 NOPs */ );
}


static int FD_55( core_crocods_t *core ) /* LD D, IYl */
{
    RegD = RegIYL;
    return( 2 /* 2 NOPs */ );
}


static int FD_56( core_crocods_t *core ) /* LD D, (IY+d) */
{
    RegD = ( UBYTE )PEEK8( core, GetIYdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int FD_5C( core_crocods_t *core ) /* LD E, IYh */
{
    RegE = RegIYH;
    return( 2 /* 2 NOPs */ );
}


static int FD_5D( core_crocods_t *core ) /* LD E, IYl */
{
    RegE = RegIYL;
    return( 2 /* 2 NOPs */ );
}


static int FD_5E( core_crocods_t *core ) /* LD E, (IY+d) */
{
    RegE = ( UBYTE )PEEK8( core, GetIYdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int FD_60( core_crocods_t *core ) /* LD IYh, B */
{
    RegIYH = RegB;
    return( 2 /* 2 NOPs */ );
}


static int FD_61( core_crocods_t *core ) /* LD IYh, C */
{
    RegIYH = RegC;
    return( 2 /* 2 NOPs */ );
}


static int FD_62( core_crocods_t *core ) /* LD IYh, D */
{
    RegIYH = RegD;
    return( 2 /* 2 NOPs */ );
}


static int FD_63( core_crocods_t *core ) /* LD IYh, E */
{
    RegIYH = RegE;
    return( 2 /* 2 NOPs */ );
}


static int FD_65( core_crocods_t *core ) /* LD IYh, IYl */
{
    RegIYH = RegIYL;
    return( 2 /* 2 NOPs */ );
}


static int FD_66( core_crocods_t *core ) /* LD H, (IY+d) */
{
    RegH = ( UBYTE )PEEK8( core, GetIYdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int FD_67( core_crocods_t *core ) /* LD IYh, A */
{
    RegIYH = RegA;
    return( 2 /* 2 NOPs */ );
}


static int FD_68( core_crocods_t *core ) /* LD IYl, B */
{
    RegIYL = RegB;
    return( 2 /* 2 NOPs */ );
}


static int FD_69( core_crocods_t *core ) /* LD IYl, C */
{
    RegIYL = RegC;
    return( 2 /* 2 NOPs */ );
}


static int FD_6A( core_crocods_t *core ) /* LD IYl, D */
{
    RegIYL = RegD;
    return( 2 /* 2 NOPs */ );
}


static int FD_6B( core_crocods_t *core ) /* LD IYl, E */
{
    RegIYL = RegE;
    return( 2 /* 2 NOPs */ );
}


static int FD_6C( core_crocods_t *core ) /* LD IYl, IYH */
{
    RegIYL = RegIYH;
    return( 2 /* 2 NOPs */ );
}


static int FD_6E( core_crocods_t *core ) /* LD L, (IY+d) */
{
    RegL = ( UBYTE )PEEK8( core, GetIYdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int FD_6F( core_crocods_t *core ) /* LD IYl, A */
{
    RegIYL = RegA;
    return( 2 /* 2 NOPs */ );
}


static int FD_70( core_crocods_t *core ) /* LD (IY+d), B */
{
    POKE8( core, GetIYdd(core), RegB );
    return( 5 /* 5 NOPs */ );
}


static int FD_71( core_crocods_t *core ) /* LD (IY+d), C */
{
    POKE8( core, GetIYdd(core), RegC );
    return( 5 /* 5 NOPs */ );
}


static int FD_72( core_crocods_t *core ) /* LD (IY+d), D */
{
    POKE8( core, GetIYdd(core), RegD );
    return( 5 /* 5 NOPs */ );
}


static int FD_73( core_crocods_t *core ) /* LD (IY+d), E */
{
    POKE8( core, GetIYdd(core), RegE );
    return( 5 /* 5 NOPs */ );
}


static int FD_74( core_crocods_t *core ) /* LD (IY+d), H */
{
    POKE8( core, GetIYdd(core), RegH );
    return( 5 /* 5 NOPs */ );
}


static int FD_75( core_crocods_t *core ) /* LD (IY+d), L */
{
    POKE8( core, GetIYdd(core), RegL );
    return( 5 /* 5 NOPs */ );
}


static int FD_77( core_crocods_t *core ) /* LD (IY+d), A */
{
    POKE8( core, GetIYdd(core), RegA );
    return( 5 /* 5 NOPs */ );
}


static int FD_7C( core_crocods_t *core ) /* LD A, IYh */
{
    RegA = RegIYH;
    return( 2 /* 2 NOPs */ );
}


static int FD_7D( core_crocods_t *core ) /* LD A, IYl */
{
    RegA = RegIYL;
    return( 2 /* 2 NOPs */ );
}


static int FD_7E( core_crocods_t *core ) /* LD A, (IY+d) */
{
    RegA = ( UBYTE )PEEK8( core, GetIYdd(core) );
    return( 5 /* 5 NOPs */ );
}


static int FD_84( core_crocods_t *core ) /* ADD A, IYh */
{
    ADD_R8( core, RegIYH );
    return( 2 /* 2 NOPs */ );
}


static int FD_85( core_crocods_t *core ) /* ADD A, IYl */
{
    ADD_R8( core, RegIYL );
    return( 2 /* 2 NOPs */ );
}


static int FD_86( core_crocods_t *core ) /* ADD A, (IY+n) */
{
    ADD_R8( core, PEEK8( core, GetIYdd(core) ) );
    return( 5 /* 5 NOPs */ );
}


static int FD_8C( core_crocods_t *core ) /* ADC A, IYh */
{
    ADC_R8( core, RegIYH );
    return( 2 /* 2 NOPs */ );
}


static int FD_8D( core_crocods_t *core ) /* ADC A, IYl */
{
    ADC_R8( core, RegIYL );
    return( 2 /* 2 NOPs */ );
}


static int FD_8E( core_crocods_t *core ) /* ADC A, (IY+n) */
{
    ADC_R8( core, PEEK8( core, GetIYdd(core)  ) );
    return( 5 /* 5 NOPs */ );
}


static int FD_94( core_crocods_t *core ) /* SUB IYh */
{
    SUB_R8( core, RegIYH );
    return( 2 /* 2 NOPs */ );
}


static int FD_95( core_crocods_t *core ) /* SUB IYl */
{
    SUB_R8( core, RegIYL );
    return( 2 /* 2 NOPs */ );
}


static int FD_96( core_crocods_t *core ) /* SUB (IY+n) */
{
    SUB_R8( core, PEEK8( core, GetIYdd(core) ) );
    return( 5 /* 5 NOPs */ );
}


static int FD_9C( core_crocods_t *core ) /* SBC A, IYh */
{
    SBC_R8( core, RegIYH );
    return( 2 /* 2 NOPs */ );
}


static int FD_9D( core_crocods_t *core ) /* SBC A, IYl */
{
    SBC_R8( core, RegIYL );
    return( 2 /* 2 NOPs */ );
}


static int FD_9E( core_crocods_t *core ) /* SBC A, (IY+n) */
{
    SBC_R8( core, PEEK8( core, GetIYdd(core) ) );
    return( 5 /* 5 NOPs */ );
}


static int FD_A4( core_crocods_t *core ) /* AND IYh */
{
    RegA &= RegIYH;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 2 /* 2 NOPs */ );
}


static int FD_A5( core_crocods_t *core ) /* AND IYl */
{
    RegA &= RegIYL;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 2 /* 2 NOPs */ );
}


static int FD_A6( core_crocods_t *core ) /* AND (IY+n) */
{
    RegA &= PEEK8( core, GetIYdd(core) );
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 5 /* 5 NOPs */ );
}


static int FD_AC( core_crocods_t *core ) /* XOR IYh */
{
    RegA ^= RegIYH;
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int FD_AD( core_crocods_t *core ) /* XOR IYl */
{
    RegA ^= RegIYL;
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int FD_AE( core_crocods_t *core ) /* XOR (IY+n) */
{
    RegA ^= PEEK8( core, GetIYdd(core) );
    FLAGS = Parite[ RegA ];
    return( 5 /* 5 NOPs */ );
}


static int FD_B4( core_crocods_t *core ) /* OR IYh */
{
    RegA |= RegIYH;
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int FD_B5( core_crocods_t *core ) /* OR IYl */
{
    RegA |= RegIYL;
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int FD_B6( core_crocods_t *core ) /* OR (IY+n) */
{
    RegA |= PEEK8( core, GetIYdd(core) );
    FLAGS = Parite[ RegA ];
    return( 5 /* 5 NOPs */ );
}


static int FD_BC( core_crocods_t *core ) /* CP IYh */
{
    CP_R8( core, RegIYH );
    return( 2 /* 2 NOPs */ );
}


static int FD_BD( core_crocods_t *core ) /* CP IYl */
{
    CP_R8( core, RegIYL );
    return( 2 /* 2 NOPs */ );
}


static int FD_BE( core_crocods_t *core ) /* CP (IY+n) */
{
    CP_R8( core, PEEK8( core, GetIYdd(core) ) );
    return( 5 /* 5 NOPs */ );
}


static int FD_CB( core_crocods_t *core ) /* special code CB */
{
    int r, tmp = RegHL;
    RegHL = ( USHORT )GetIYdd(core);
    CBIndex = 1;
    r = tabCB[ PEEK8( core, RegPC++ ) ](core);
    CBIndex = 0;
    RegHL = ( USHORT )tmp;
    return( r + 4 ); // ### a vérifier...
}


static int FD_DD( core_crocods_t *core ) /* special FD_DD */
{
    // Se comporte comme un simple DD
    RegR = ( UBYTE )( ( ( RegR + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ) );
    return( 1 + tabIX[ PEEK8( core, RegPC++ ) ](core) ); // ### A vérifier
}


static int FD_E1( core_crocods_t *core ) /* POP IY */
{
    RegIY = PEEK16( core, RegSP );
    RegSP += 2;
    return( 5 /* 5 NOPs */ );
}


static int FD_E3( core_crocods_t *core ) /* EX (SP), IY */
{
    USHORT a = PEEK16( core, RegSP );
    POKE16( core, RegSP, RegIY );
    RegIY = a;
    return( 7 /* 7 NOPs */ );
}


static int FD_E5( core_crocods_t *core ) /* PUSH IY */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegIY );
    return( 5 /* 5 NOPs */ );
}


static int FD_E9( core_crocods_t *core ) /* JP (IY) */
{
    RegPC = RegIY;
    return( 2 /* 2 NOPs */ );
}


static int FD_F9( core_crocods_t *core ) /* LD SP, IY */
{
    RegSP = RegIY;
    return( 3 /* 3 NOPs */ );
}


/*******************
 * OPCODE Standards *
 *******************/


static int NO_OP( core_crocods_t *core )
{
    return( 1 /* 1 NOP */ );
}


static int ___01( core_crocods_t *core ) /* LD BC, nnnn */
{
    RegBC = PEEK16( core, RegPC );
    RegPC += 2;
    return( 3 /* 3 NOPs */ );
}


static int ___02( core_crocods_t *core ) /* LD ( BC ), A */
{
    POKE8( core, RegBC, RegA );
    return( 2 /* 2 NOPs */ );
}


static int ___03( core_crocods_t *core ) /* INC BC */
{
    RegBC++;
    return( 2 /* 2 NOPs */ );
}


static int ___04( core_crocods_t *core ) /* INC B */
{
    FLAG_INC( core, ++RegB );
    return( 1 /* 1 NOP */ );
}


static int ___05( core_crocods_t *core ) /* DEC B */
{
    FLAG_DEC( core, --RegB );
    return( 1 /* 1 NOP */ );
}


static int ___06( core_crocods_t *core ) /* LD B, n */
{
    RegB = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___07( core_crocods_t *core ) /* RLCA */
{
    FLAGS = ( UBYTE )( ( FLAGS & ( ~FLAG_C & ~FLAG_N & ~FLAG_H ) )
                      | ( RegA >> 7 )
                      );
    RegA = ( UBYTE )( ( RegA << 1 ) | ( FLAGS & FLAG_C ) );
    return( 1 /* 1 NOP */ );
}


static int ___08( core_crocods_t *core ) /* EX AF, AF' */
{
    USHORT tmp = RegAF;
    RegAF = Reg_AF;
    Reg_AF = tmp;
    return( 1 /* 1 NOP */ );
}


static int ___09( core_crocods_t *core ) /* ADD HL, BC */
{
    ADD_R16( core, &RegHL, RegBC );
    return( 3 /* 3 NOPs */ );
}


static int ___0A( core_crocods_t *core ) /* LD A, ( BC ) */
{
    RegA = ( UBYTE )PEEK8( core, RegBC );
    return( 2 /* 2 NOPs */ );
}


static int ___0B( core_crocods_t *core ) /* DEC BC */
{
    RegBC--;
    return( 2 /* 2 NOPs */ );
}


static int ___0C( core_crocods_t *core ) /* INC C */
{
    FLAG_INC( core, ++RegC );
    return( 1 /* 1 NOP */ );
}


static int ___0D( core_crocods_t *core ) /* DEC C */
{
    FLAG_DEC( core, --RegC );
    return( 1 /* 1 NOP */ );
}


static int ___0E( core_crocods_t *core ) /* LD C, n */
{
    RegC = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___0F( core_crocods_t *core ) /* RRCA */
{
    FLAGS = ( UBYTE )( ( FLAGS & ( ~FLAG_C & ~FLAG_N & ~FLAG_H ) )
                      | ( RegA & FLAG_C )
                      );
    RegA = ( UBYTE )( ( RegA >> 1 ) | ( FLAGS << 7 ) );
    return( 1 /* 1 NOP */ );
}


static int ___10( core_crocods_t *core ) /* DJNZ e */
{
    int r = 3;
    if ( --RegB )
    {
        RegPC = ( USHORT )( RegPC + ( signed char )PEEK8( core, RegPC ) );
        r++;
    }
    RegPC++;
    return( r );
}


static int ___11( core_crocods_t *core ) /* LD DE, nnnn */
{
    RegDE = PEEK16( core, RegPC );
    RegPC += 2;
    return( 3 /* 3 NOPs */ );
}


static int ___12( core_crocods_t *core ) /* LD ( DE ), A */
{
    POKE8( core, RegDE, RegA );
    return( 2 /* 2 NOPs */ );
}


static int ___13( core_crocods_t *core ) /* INC DE */
{
    RegDE++;
    return( 2 /* 2 NOPs */ );
}


static int ___14( core_crocods_t *core ) /* INC D */
{
    FLAG_INC( core, ++RegD );
    return( 1 /* 1 NOP */ );
}


static int ___15( core_crocods_t *core ) /* DEC D */
{
    FLAG_DEC( core, --RegD );
    return( 1 /* 1 NOP */ );
}


static int ___16( core_crocods_t *core ) /* LD D, n */
{
    RegD = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___17( core_crocods_t *core ) /* RLA */
{
    int i = RegA << 1;
    RegA = ( UBYTE )( i | ( FLAGS & FLAG_C ) );
    FLAGS = ( UBYTE )( ( FLAGS & ( ~FLAG_C & ~FLAG_N & ~FLAG_H ) )
                      | ( i >> 8 )
                      );
    return( 1 /* 1 NOP */ );
}


static int ___18( core_crocods_t *core ) /* JR e */
{
    RegPC = ( USHORT )( RegPC + ( signed char )PEEK8( core, RegPC ) );
    RegPC++;
    return( 3 /* 3 NOPs */ );
}


static int ___19( core_crocods_t *core ) /* ADD HL, DE */
{
    ADD_R16( core, &RegHL, RegDE );
    return( 3 /* 3 NOPs */ );
}


static int ___1A( core_crocods_t *core ) /* LD A, ( DE ) */
{
    RegA = ( UBYTE )PEEK8( core, RegDE );
    return( 2 /* 2 NOPs */ );
}


static int ___1B( core_crocods_t *core ) /* DEC DE */
{
    RegDE--;
    return( 2 /* 2 NOPs */ );
}


static int ___1C( core_crocods_t *core ) /* INC E */
{
    FLAG_INC( core, ++RegE );
    return( 1 /* 1 NOP */ );
}


static int ___1D( core_crocods_t *core ) /* DEC E */
{
    FLAG_DEC( core, --RegE );
    return( 1 /* 1 NOP */ );
}


static int ___1E( core_crocods_t *core ) /* LD E, n */
{
    RegE = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___1F( core_crocods_t *core ) /* RRA */
{
    int i = ( RegA >> 1 ) | ( ( FLAGS << 7 ) & 128 );
    FLAGS = ( UBYTE )( ( FLAGS & ( ~FLAG_C & ~FLAG_N & ~FLAG_H ) )
                      | ( RegA & FLAG_C )
                      );
    RegA = ( UBYTE )i;
    return( 1 /* 1 NOP */ );
}


static int ___20( core_crocods_t *core ) /* JR NZ, e */
{
    int r = 2;
    if ( ! ( FLAGS & FLAG_Z ) )
    {
        RegPC = ( USHORT )( RegPC + ( signed char )PEEK8( core, RegPC ) );
        r++;
    }
    RegPC++;
    return( r );
}


static int ___21( core_crocods_t *core ) /* LD HL, nnnn */
{
    RegHL = PEEK16( core, RegPC );
    RegPC += 2;
    return( 3 /* 3 NOPs */ );
}


static int ___22( core_crocods_t *core ) /* LD ( nnnn ), HL */
{
    POKE16( core, PEEK16( core, RegPC ), RegHL );
    RegPC += 2;
    return( 5 /* 5 NOPs */ );
}


static int ___23( core_crocods_t *core ) /* INC HL */
{
    RegHL++;
    return( 2 /* 2 NOPs */ );
}


static int ___24( core_crocods_t *core ) /* INC H */
{
    FLAG_INC( core, ++RegH );
    return( 1 /* 1 NOP */ );
}


static int ___25( core_crocods_t *core ) /* DEC H */
{
    FLAG_DEC( core, --RegH );
    return( 1 /* 1 NOP */ );
}


static int ___26( core_crocods_t *core ) /* LD H, n */
{
    RegH = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___27( core_crocods_t *core ) /* DAA */
{
    RegAF = TabDAA[ RegA
                   | ( ( FLAGS & FLAG_H ) << 6 )
                   | ( ( FLAGS & ( FLAG_N | FLAG_C ) ) << 8 )
                   ];
    return( 1 /* 1 NOP */ );
}


static int ___28( core_crocods_t *core ) /* JR Z, e */
{
    int r = 2;
    if ( FLAGS & FLAG_Z )
    {
        RegPC = ( USHORT )( RegPC + ( signed char )PEEK8( core, RegPC ) );
        r++;
    }
    RegPC++;
    return( r );
}


static int ___29( core_crocods_t *core ) /* ADD HL, HL */
{
    ADD_R16( core, &RegHL, RegHL );
    return( 3 /* 3 NOPs */ );
}


static int ___2A( core_crocods_t *core ) /* LD HL, ( nnnn ) */
{
    RegHL = PEEK16( core, PEEK16( core, RegPC ) );
    RegPC += 2;
    return( 5 /* 5 NOPs */ );
}


static int ___2B( core_crocods_t *core ) /* DEC HL */
{
    RegHL--;
    return( 2 /* 2 NOPs */ );
}


static int ___2C( core_crocods_t *core ) /* INC L */
{
    FLAG_INC( core, ++RegL );
    return( 1 /* 1 NOP */ );
}


static int ___2D( core_crocods_t *core ) /* DEC L */
{
    FLAG_DEC( core, --RegL );
    return( 1 /* 1 NOP */ );
}


static int ___2E( core_crocods_t *core ) /* LD L, n */
{
    RegL = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___2F( core_crocods_t *core ) /* CPL */
{
    RegAF = ( USHORT )( ( RegAF ^ 0xFF00 ) | ( FLAG_H | FLAG_N ) );
    return( 1 /* 1 NOP */ );
}


static int ___30( core_crocods_t *core ) /* JR NC, e */
{
    int r = 2;
    if ( ! ( FLAGS & FLAG_C ) )
    {
        RegPC = ( USHORT )( RegPC + ( signed char )PEEK8( core, RegPC ) );
        r++;
    }
    RegPC++;
    return( r );
}


static int ___31( core_crocods_t *core ) /* LD SP, nnnn */
{
    RegSP = PEEK16( core, RegPC );
    RegPC += 2;
    return( 3 /* 3 NOPs */ );
}


static int ___32( core_crocods_t *core ) /* LD ( nnnn ), A */
{
    POKE8( core, PEEK16( core, RegPC ), RegA );
    RegPC += 2;
    return( 4 /* 4 NOPs */ );
}


static int ___33( core_crocods_t *core ) /* INC SP */
{
    RegSP++;
    return( 2 /* 2 NOPs */ );
}


static int ___34( core_crocods_t *core ) /* INC ( HL ) */
{
    UBYTE r = ( UBYTE )PEEK8( core, RegHL );
    FLAG_INC(  core, ++r );
    POKE8( core, RegHL, r );
    return( 3 /* 3 NOPs */ );
}


static int ___35( core_crocods_t *core ) /* DEC ( HL ) */
{
    UBYTE r = ( UBYTE )PEEK8( core, RegHL );
    FLAG_DEC( core, --r );
    POKE8( core, RegHL, r );
    return( 3 /* 3 NOPs */ );
}


static int ___36( core_crocods_t *core ) /* LD ( HL ), n */
{
    POKE8( core, RegHL, ( UBYTE )PEEK8( core, RegPC ) );
    RegPC++;
    return( 3 /* 3 NOPs */ );
}


static int ___37( core_crocods_t *core ) /* SCF */
{
    FLAGS = ( UBYTE )( ( FLAGS | FLAG_C ) & ( ~FLAG_N & ~FLAG_H ) );
    return( 1 /* 1 NOP */ );
}


static int ___38( core_crocods_t *core ) /* JR C, e */
{
    int r = 2;
    if ( FLAGS & FLAG_C )
    {
        RegPC = ( USHORT )( RegPC + ( signed char )PEEK8( core, RegPC ) );
        r++;
    }
    RegPC++;
    return( r );
}


static int ___39( core_crocods_t *core ) /* ADD HL, SP */
{
    ADD_R16( core, &RegHL, RegSP );
    return( 3 /* 3 NOPs */ );
}


static int ___3A( core_crocods_t *core ) /* LD A, ( nnnn ) */
{
    RegA = ( UBYTE )PEEK8( core, PEEK16( core, RegPC ) );
    RegPC += 2;
    return( 4 /* 4 NOPs */ );
}


static int ___3B( core_crocods_t *core ) /* DEC SP */
{
    RegSP--;
    return( 2 /* 2 NOPs */ );
}


static int ___3C( core_crocods_t *core ) /* INC A */
{
    FLAG_INC( core, ++RegA );
    return( 1 /* 1 NOP */ );
}


static int ___3D( core_crocods_t *core ) /* DEC A */
{
    FLAG_DEC( core, --RegA );
    return( 1 /* 1 NOP */ );
}


static int ___3E( core_crocods_t *core ) /* LD A, ee */
{
    RegA = ( UBYTE )PEEK8( core, RegPC );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___3F( core_crocods_t *core ) /* CCF */
{
    int tmp = ( FLAGS & FLAG_C ) << 4;
    FLAGS = ( UBYTE )( (( FLAGS ^ FLAG_C ) & ( ~FLAG_N & ~FLAG_H )) | tmp );
    return( 1 /* 1 NOP */ );
}


static int ___41( core_crocods_t *core ) /* LD B, C */
{
    RegB = RegC;
    return( 1 /* 1 NOP */ );
}


static int ___42( core_crocods_t *core ) /* LD B, D */
{
    RegB = RegD;
    return( 1 /* 1 NOP */ );
}


static int ___43( core_crocods_t *core ) /* LD B, E */
{
    RegB = RegE;
    return( 1 /* 1 NOP */ );
}


static int ___44( core_crocods_t *core ) /* LD B, H */
{
    RegB = RegH;
    return( 1 /* 1 NOP */ );
}


static int ___45( core_crocods_t *core ) /* LD B, L */
{
    RegB = RegL;
    return( 1 /* 1 NOP */ );
}


static int ___46( core_crocods_t *core ) /* LD B, ( HL ) */
{
    RegB = ( UBYTE )PEEK8( core, RegHL );
    return( 2 /* 2 NOPs */ );
}


static int ___47( core_crocods_t *core ) /* LD B, A */
{
    RegB = RegA;
    return( 1 /* 1 NOP */ );
}


static int ___48( core_crocods_t *core ) /* LD C, B */
{
    RegC = RegB;
    return( 1 /* 1 NOP */ );
}


static int ___4A( core_crocods_t *core ) /* LD C, D */
{
    RegC = RegD;
    return( 1 /* 1 NOP */ );
}


static int ___4B( core_crocods_t *core ) /* LD C, E */
{
    RegC = RegE;
    return( 1 /* 1 NOP */ );
}


static int ___4C( core_crocods_t *core ) /* LD C, H */
{
    RegC = RegH;
    return( 1 /* 1 NOP */ );
}


static int ___4D( core_crocods_t *core ) /* LD C, L */
{
    RegC = RegL;
    return( 1 /* 1 NOP */ );
}


static int ___4E( core_crocods_t *core ) /* LD C, ( HL ) */
{
    RegC = ( UBYTE )PEEK8( core, RegHL );
    return( 2 /* 2 NOPs */ );
}


static int ___4F( core_crocods_t *core ) /* LD C, A */
{
    RegC = RegA;
    return( 1 /* 1 NOP */ );
}


static int ___50( core_crocods_t *core ) /* LD D, B */
{
    RegD = RegB;
    return( 1 /* 1 NOP */ );
}


static int ___51( core_crocods_t *core ) /* LD D, C */
{
    RegD = RegC;
    return( 1 /* 1 NOP */ );
}


static int ___53( core_crocods_t *core ) /* LD D, E */
{
    RegD = RegE;
    return( 1 /* 1 NOP */ );
}


static int ___54( core_crocods_t *core ) /* LD D, H */
{
    RegD = RegH;
    return( 1 /* 1 NOP */ );
}


static int ___55( core_crocods_t *core ) /* LD D, L */
{
    RegD = RegL;
    return( 1 /* 1 NOP */ );
}


static int ___56( core_crocods_t *core ) /* LD D, ( HL ) */
{
    RegD = ( UBYTE )PEEK8( core, RegHL );
    return( 2 /* 2 NOPs */ );
}


static int ___57( core_crocods_t *core ) /* LD D, A */
{
    RegD = RegA;
    return( 1 /* 1 NOP */ );
}


static int ___58( core_crocods_t *core ) /* LD E, B */
{
    RegE = RegB;
    return( 1 /* 1 NOP */ );
}


static int ___59( core_crocods_t *core ) /* LD E, C */
{
    RegE = RegC;
    return( 1 /* 1 NOP */ );
}


static int ___5A( core_crocods_t *core ) /* LD E, D */
{
    RegE = RegD;
    return( 1 /* 1 NOP */ );
}


static int ___5C( core_crocods_t *core ) /* LD E, H */
{
    RegE = RegH;
    return( 1 /* 1 NOP */ );
}


static int ___5D( core_crocods_t *core ) /* LD E, L */
{
    RegE = RegL;
    return( 1 /* 1 NOP */ );
}


static int ___5E( core_crocods_t *core ) /* LD E, ( HL ) */
{
    RegE = ( UBYTE )PEEK8( core, RegHL );
    return( 2 /* 2 NOPs */ );
}


static int ___5F( core_crocods_t *core ) /* LD E, A */
{
    RegE = RegA;
    return( 1 /* 1 NOP */ );
}


static int ___60( core_crocods_t *core ) /* LD H, B */
{
    RegH = RegB;
    return( 1 /* 1 NOP */ );
}


static int ___61( core_crocods_t *core ) /* LD H, C */
{
    RegH = RegC;
    return( 1 /* 1 NOP */ );
}


static int ___62( core_crocods_t *core ) /* LD H, D */
{
    RegH = RegD;
    return( 1 /* 1 NOP */ );
}


static int ___63( core_crocods_t *core ) /* LD H, E */
{
    RegH = RegE;
    return( 1 /* 1 NOP */ );
}


static int ___65( core_crocods_t *core ) /* LD H, L */
{
    RegH = RegL;
    return( 1 /* 1 NOP */ );
}


static int ___66( core_crocods_t *core ) /* LD H, ( HL ) */
{
    RegH = ( UBYTE )PEEK8( core, RegHL );
    return( 2 /* 2 NOPs */ );
}


static int ___67( core_crocods_t *core ) /* LD H, A */
{
    RegH = RegA;
    return( 1 /* 1 NOP */ );
}


static int ___68( core_crocods_t *core ) /* LD L, B */
{
    RegL = RegB;
    return( 1 /* 1 NOP */ );
}


static int ___69( core_crocods_t *core ) /* LD L, C */
{
    RegL = RegC;
    return( 1 /* 1 NOP */ );
}


static int ___6A( core_crocods_t *core ) /* LD L, D */
{
    RegL = RegD;
    return( 1 /* 1 NOP */ );
}


static int ___6B( core_crocods_t *core ) /* LD L, E */
{
    RegL = RegE;
    return( 1 /* 1 NOP */ );
}


static int ___6C( core_crocods_t *core ) /* LD L, H */
{
    RegL = RegH;
    return( 1 /* 1 NOP */ );
}


static int ___6E( core_crocods_t *core ) /* LD L, ( HL ) */
{
    RegL = ( UBYTE )PEEK8( core, RegHL );
    return( 2 /* 2 NOPs */ );
}


static int ___6F( core_crocods_t *core ) /* LD L, A */
{
    RegL = RegA;
    return( 1 /* 1 NOP */ );
}


static int ___70( core_crocods_t *core ) /* LD ( HL ), B */
{
    POKE8( core, RegHL, RegB );
    return( 2 /* 2 NOPs */ );
}


static int ___71( core_crocods_t *core ) /* LD ( HL ), C */
{
    POKE8( core, RegHL, RegC );
    return( 2 /* 2 NOPs */ );
}


static int ___72( core_crocods_t *core ) /* LD ( HL ), D */
{
    POKE8( core, RegHL, RegD );
    return( 2 /* 2 NOPs */ );
}


static int ___73( core_crocods_t *core ) /* LD ( HL ), E */
{
    POKE8( core, RegHL, RegE );
    return( 2 /* 2 NOPs */ );
}


static int ___74( core_crocods_t *core ) /* LD ( HL ), H */
{
    POKE8( core, RegHL, RegH );
    return( 2 /* 2 NOPs */ );
}


static int ___75( core_crocods_t *core ) /* LD ( HL ), L */
{
    POKE8( core, RegHL, RegL );
    return( 2 /* 2 NOPs */ );
}


static int ___76( core_crocods_t *core ) /* HALT */
{
#ifndef HACK_IRQ
    if ( ! core->IRQ ) RegPC--;
#else
    RegPC--;
    core->halted=1;
#endif
    
    return( 1 /* 1 NOP */ );
}


static int ___77( core_crocods_t *core ) /* LD ( HL ), A */
{
    POKE8( core, RegHL, RegA );
    return( 2 /* 2 NOPs */ );
}


static int ___78( core_crocods_t *core ) /* LD A, B */
{
    RegA = RegB;
    return( 1 /* 1 NOP */ );
}


static int ___79( core_crocods_t *core ) /* LD A, C */
{
    RegA = RegC ;
    return( 1 /* 1 NOP */ );
}


static int ___7A( core_crocods_t *core ) /* LD A, D */
{
    RegA = RegD;
    return( 1 /* 1 NOP */ );
}


static int ___7B( core_crocods_t *core ) /* LD A, E */
{
    RegA = RegE;
    return( 1 /* 1 NOP */ );
}


static int ___7C( core_crocods_t *core ) /* LD A, H */
{
    RegA = RegH;
    return( 1 /* 1 NOP */ );
}


static int ___7D( core_crocods_t *core ) /* LD A, L */
{
    RegA = RegL;
    return( 1 /* 1 NOP */ );
}


static int ___7E( core_crocods_t *core ) /* LD A, ( HL ) */
{
    RegA = ( UBYTE )PEEK8( core, RegHL );
    return( 2 /* 2 NOPs */ );
}


static int ___80( core_crocods_t *core ) /* ADD A, B */
{
    ADD_R8( core, RegB );
    return( 1 /* 1 NOP */ );
}


static int ___81( core_crocods_t *core ) /* ADD A, C */
{
    ADD_R8( core, RegC );
    return( 1 /* 1 NOP */ );
}


static int ___82( core_crocods_t *core ) /* ADD A, D */
{
    ADD_R8( core, RegD );
    return( 1 /* 1 NOP */ );
}


static int ___83( core_crocods_t *core ) /* ADD A, E */
{
    ADD_R8( core, RegE );
    return( 1 /* 1 NOP */ );
}


static int ___84( core_crocods_t *core ) /* ADD A, H */
{
    ADD_R8( core, RegH );
    return( 1 /* 1 NOP */ );
}


static int ___85( core_crocods_t *core ) /* ADD A, L */
{
    ADD_R8( core, RegL );
    return( 1 /* 1 NOP */ );
}


static int ___86( core_crocods_t *core ) /* ADD A, ( HL ) */
{
    ADD_R8( core, PEEK8( core, RegHL ) );
    return( 2 /* 2 NOPs */ );
}


static int ___87( core_crocods_t *core ) /* ADD A, A */
{
    ADD_R8( core, RegA );
    return( 1 /* 1 NOP */ );
}


static int ___88( core_crocods_t *core ) /* ADC A, B */
{
    ADC_R8( core, RegB );
    return( 1 /* 1 NOP */ );
}


static int ___89( core_crocods_t *core ) /* ADC A, C */
{
    ADC_R8( core, RegC );
    return( 1 /* 1 NOP */ );
}


static int ___8A( core_crocods_t *core ) /* ADC A, D */
{
    ADC_R8( core, RegD );
    return( 1 /* 1 NOP */ );
}


static int ___8B( core_crocods_t *core ) /* ADC A, E */
{
    ADC_R8( core, RegE );
    return( 1 /* 1 NOP */ );
}


static int ___8C( core_crocods_t *core ) /* ADC A, H */
{
    ADC_R8( core, RegH );
    return( 1 /* 1 NOP */ );
}


static int ___8D( core_crocods_t *core ) /* ADC A, L */
{
    ADC_R8( core, RegL );
    return( 1 /* 1 NOP */ );
}


static int ___8E( core_crocods_t *core ) /* ADC A, (HL) */
{
    ADC_R8( core, PEEK8( core, RegHL ) );
    return( 2 /* 2 NOPs */ );
}


static int ___8F( core_crocods_t *core ) /* ADC A, A */
{
    ADC_R8( core, RegA );
    return( 1 /* 1 NOP */ );
}


static int ___90( core_crocods_t *core ) /* SUB B */
{
    SUB_R8( core, RegB );
    return( 1 /* 1 NOP */ );
}


static int ___91( core_crocods_t *core ) /* SUB C */
{
    SUB_R8( core, RegC );
    return( 1 /* 1 NOP */ );
}


static int ___92( core_crocods_t *core ) /* SUB D */
{
    SUB_R8( core, RegD );
    return( 1 /* 1 NOP */ );
}


static int ___93( core_crocods_t *core ) /* SUB E */
{
    SUB_R8( core, RegE );
    return( 1 /* 1 NOP */ );
}


static int ___94( core_crocods_t *core ) /* SUB H */
{
    SUB_R8( core, RegH );
    return( 1 /* 1 NOP */ );
}


static int ___95( core_crocods_t *core ) /* SUB L */
{
    SUB_R8( core, RegL );
    return( 1 /* 1 NOP */ );
}


static int ___96( core_crocods_t *core ) /* SUB (HL) */
{
    SUB_R8( core, PEEK8( core, RegHL ) );
    return( 2 /* 2 NOPs */ );
}


static int ___97( core_crocods_t *core ) /* SUB A */
{
    RegAF = ( USHORT )( FLAG_N | FLAG_Z );
    return( 1 /* 1 NOP */ );
}


static int ___98( core_crocods_t *core ) /* SBC A, B */
{
    SBC_R8( core, RegB );
    return( 1 /* 1 NOP */ );
}


static int ___99( core_crocods_t *core ) /* SBC A, C */
{
    SBC_R8( core, RegC );
    return( 1 /* 1 NOP */ );
}


static int ___9A( core_crocods_t *core ) /* SBC A, D */
{
    SBC_R8( core, RegD );
    return( 1 /* 1 NOP */ );
}


static int ___9B( core_crocods_t *core ) /* SBC A, E */
{
    SBC_R8( core, RegE );
    return( 1 /* 1 NOP */ );
}


static int ___9C( core_crocods_t *core ) /* SBC A, H */
{
    SBC_R8( core, RegH );
    return( 1 /* 1 NOP */ );
}


static int ___9D( core_crocods_t *core ) /* SBC A, L */
{
    SBC_R8( core, RegL );
    return( 1 /* 1 NOP */ );
}


static int ___9E( core_crocods_t *core ) /* SBC A, (HL) */
{
    SBC_R8( core, PEEK8( core, RegHL ) );
    return( 2 /* 2 NOPs */ );
}


static int ___9F( core_crocods_t *core ) /* SBC A, A */
{
    SBC_R8( core, RegA );
    return( 1 /* 1 NOP */ );
}


static int ___A0( core_crocods_t *core ) /* AND B */
{
    RegA &= RegB;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 1 /* 1 NOP */ );
}


static int ___A1( core_crocods_t *core ) /* AND C */
{
    RegA &= RegC;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 1 /* 1 NOP */ );
}


static int ___A2( core_crocods_t *core ) /* AND D */
{
    RegA &= RegD;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 1 /* 1 NOP */ );
}


static int ___A3( core_crocods_t *core ) /* AND E */
{
    RegA &= RegE;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 1 /* 1 NOP */ );
}


static int ___A4( core_crocods_t *core ) /* AND H */
{
    RegA &= RegH;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 1 /* 1 NOP */ );
}


static int ___A5( core_crocods_t *core ) /* AND L */
{
    RegA &= RegL;
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 1 /* 1 NOP */ );
}


static int ___A6( core_crocods_t *core ) /* AND (HL) */
{
    RegA &= PEEK8( core, RegHL );
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 2 /* 2 NOPs */ );
}


static int ___A7( core_crocods_t *core ) /* AND A */
{
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    return( 1 /* 1 NOP */ );
}


static int ___A8( core_crocods_t *core ) /* XOR B */
{
    RegA ^= RegB;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___A9( core_crocods_t *core ) /* XOR C */
{
    RegA ^= RegC;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___AA( core_crocods_t *core ) /* XOR D */
{
    RegA ^= RegD;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___AB( core_crocods_t *core ) /* XOR E */
{
    RegA ^= RegE;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___AC( core_crocods_t *core ) /* XOR H */
{
    RegA ^= RegH;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___AD( core_crocods_t *core ) /* XOR L */
{
    RegA ^= RegL;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___AE( core_crocods_t *core ) /* XOR (HL) */
{
    RegA ^= PEEK8( core, RegHL );
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int ___AF( core_crocods_t *core ) /* XOR A */
{
    RegAF = FLAG_Z | FLAG_V;
    return( 1 /* 1 NOP */ );
}


static int ___B0( core_crocods_t *core ) /* OR B */
{
    RegA |= RegB;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___B1( core_crocods_t *core ) /* OR C */
{
    RegA |= RegC;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___B2( core_crocods_t *core ) /* OR D */
{
    RegA |= RegD;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___B3( core_crocods_t *core ) /* OR E */
{
    RegA |= RegE;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___B4( core_crocods_t *core ) /* OR H */
{
    RegA |= RegH;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___B5( core_crocods_t *core ) /* OR L */
{
    RegA |= RegL;
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___B6( core_crocods_t *core ) /* OR (HL) */
{
    RegA |= PEEK8( core, RegHL );
    FLAGS = Parite[ RegA ];
    return( 2 /* 2 NOPs */ );
}


static int ___B7( core_crocods_t *core ) /* OR A */
{
    FLAGS = Parite[ RegA ];
    return( 1 /* 1 NOP */ );
}


static int ___B8( core_crocods_t *core ) /* CP B */
{
    CP_R8( core, RegB );
    return( 1 /* 1 NOP */ );
}


static int ___B9( core_crocods_t *core ) /* CP C */
{
    CP_R8( core, RegC );
    return( 1 /* 1 NOP */ );
}


static int ___BA( core_crocods_t *core ) /* CP D */
{
    CP_R8( core, RegD );
    return( 1 /* 1 NOP */ );
}


static int ___BB( core_crocods_t *core ) /* CP E */
{
    CP_R8( core, RegE );
    return( 1 /* 1 NOP */ );
}


static int ___BC( core_crocods_t *core ) /* CP H */
{
    CP_R8( core, RegH );
    return( 1 /* 1 NOP */ );
}


static int ___BD( core_crocods_t *core ) /* CP L */
{
    CP_R8( core, RegL );
    return( 1 /* 1 NOP */ );
}


static int ___BE( core_crocods_t *core ) /* CP (HL) */
{
    CP_R8( core, PEEK8( core, RegHL ) );
    return( 2 /* 2 NOPs */ );
}


static int ___BF( core_crocods_t *core ) /* CP A */
{
    FLAGS = FLAG_N | FLAG_Z;
    return( 1 /* 1 NOP */ );
}


static int ___C0( core_crocods_t *core ) /* RET NZ */
{
    if ( ! ( FLAGS & FLAG_Z ) )
    {
        RegPC = PEEK16( core, RegSP );
        RegSP += 2;
        return( 4 /* 4 NOPs */ );
    }
    else
        return( 2 /* 2 NOPs */ );
}


static int ___C1( core_crocods_t *core ) /* POP BC */
{
    RegBC = PEEK16( core, RegSP );
    RegSP += 2;
    return( 3 /* 3 NOPs */ );
}


static int ___C2( core_crocods_t *core ) /* JP NZ, nnnn */
{
    if ( ! ( FLAGS & FLAG_Z ) )
    {
        RegPC = PEEK16( core, RegPC );
    }
    else
        RegPC += 2;
    
    return( 3 /* 3 NOPs */ );
}


static int ___C3( core_crocods_t *core ) /* JP nnnn */
{
    RegPC = PEEK16( core, RegPC );
    return( 3 /* 3 NOPs */ );
}


static int ___C4( core_crocods_t *core ) /* CALL NZ, nnnn */
{
    if ( ! ( FLAGS & FLAG_Z ) )
    {
        RegSP -= 2;
        POKE16( core, RegSP, ( USHORT )( RegPC + 2 ) );
        RegPC = PEEK16( core, RegPC );
        return( 5 /* 5 NOPs */ );
    }
    else
    {
        RegPC += 2;
        return( 3 /* 3 NOPs */ );
    }
}


static int ___C5( core_crocods_t *core ) /* PUSH BC */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegBC );
    return( 4 /* 4 NOPs */ );
}


static int ___C6( core_crocods_t *core ) /* ADD A, ee */
{
    ADD_R8( core, PEEK8( core, RegPC ) );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___C7( core_crocods_t *core ) /* RST 00 */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegPC );
    RegPC = 0x00;
    return( 4 /* 4 NOPs */ );
}


static int ___C8( core_crocods_t *core ) /* RET Z */
{
    if ( FLAGS & FLAG_Z )
    {
        RegPC = PEEK16( core, RegSP );
        RegSP += 2;
        return( 4 /* 4 NOPs */ );
    }
    else
        return( 2 /* 2 NOPs */ );
}


int ___C9( core_crocods_t *core ) /* RET */
{
    RegPC = PEEK16( core, RegSP );
    RegSP += 2;
    return( 3 /* 3 NOPs */ );
}


static int ___CA( core_crocods_t *core ) /* JP Z, nnnn */
{
    if ( FLAGS & FLAG_Z )
    {
        RegPC = PEEK16( core, RegPC );
    }
    else
        RegPC += 2;
    
    return( 3 /* 3 NOPs */ );
}



static int ___CB( core_crocods_t *core ) /* Special code CB */
{
    RegR = ( UBYTE )( ( ( RegR + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ) );
    int r = tabCB[ PEEK8( core, RegPC++ ) ](core);
    return( r );
}


static int ___CC( core_crocods_t *core ) /* CALL Z, nnnn */
{
    if ( FLAGS & FLAG_Z )
    {
        RegSP -= 2;
        POKE16( core, RegSP, ( USHORT )( RegPC + 2 ) );
        RegPC = PEEK16( core, RegPC );
        return( 5 /* 5 NOPs */ );
    }
    else
    {
        RegPC += 2;
        return( 3 /* 3 NOPs */ );
    }
}


static int ___CD( core_crocods_t *core ) /* CALL nnnn */
{
    u16 adr=0;
    
    RegSP -= 2;
    POKE16( core, RegSP, ( USHORT )( RegPC + 2 ) );
    adr = PEEK16( core, RegPC );
    
    
    RegPC = adr;
    
    return( 5 /* 5 NOPs */ );
}


static int ___CE( core_crocods_t *core ) /* ADC A, ee */
{
    ADC_R8( core, PEEK8( core, RegPC ) );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___CF( core_crocods_t *core ) /* RST 08 */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegPC );
    RegPC = 0x08;
    return( 4 /* 4 NOPs */ );
}


static int ___D0( core_crocods_t *core ) /* RET NC */
{
    if ( ! ( FLAGS & FLAG_C ) )
    {
        RegPC = PEEK16( core, RegSP );
        RegSP += 2;
        return( 4 /* 4 NOPs */ );
    }
    else
        return( 2 /* 2 NOPs */ );
}


static int ___D1( core_crocods_t *core ) /* POP DE */
{
    RegDE = PEEK16( core, RegSP );
    RegSP += 2;
    return( 3 /* 3 NOPs */ );
}


static int ___D2( core_crocods_t *core ) /* JP NC, nnnn */
{
    if ( ! ( FLAGS & FLAG_C ) )
    {
        RegPC = PEEK16( core, RegPC );
    }
    else
        RegPC += 2;
    
    return( 3 /* 3 NOPs */ );
}


static int ___D3( core_crocods_t *core ) /* OUT ( n ), A */
{
    WritePort( core, ( RegA << 8 ) + PEEK8( core, RegPC ), RegA );
    RegPC++;
    return( 3 /* 3 NOPs */ );
}


static int ___D4( core_crocods_t *core ) /* CALL NC, nnnn */
{
    if ( ! ( FLAGS & FLAG_C ) )
    {
        RegSP -= 2;
        POKE16( core, RegSP, ( USHORT )( RegPC + 2 ) );
        RegPC = PEEK16( core, RegPC );
        return( 5 /* 5 NOPs */ );
    }
    else
    {
        RegPC += 2;
        return( 3 /* 3 NOPs */ );
    }
}


static int ___D5( core_crocods_t *core ) /* PUSH DE */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegDE );
    return( 4 /* 4 NOPs */ );
}


static int ___D6( core_crocods_t *core ) /* SUB ee */
{
    SUB_R8( core, PEEK8( core, RegPC ) );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___D7( core_crocods_t *core ) /* RST 10 */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegPC );
    RegPC = 0x10;
    return( 4 /* 4 NOPs */ );
}


static int ___D8( core_crocods_t *core ) /* RET C */
{
    if ( FLAGS & FLAG_C )
    {
        RegPC = PEEK16( core, RegSP );
        RegSP += 2;
        return( 4 /* 4 NOPs */ );
    }
    else
        return( 2 /* 2 NOPs */ );
}


static int ___D9( core_crocods_t *core ) /* EXX */
{
    USHORT tmp = RegBC;
    RegBC = Reg_BC;
    Reg_BC = tmp;
    
    tmp = RegDE;
    RegDE = Reg_DE;
    Reg_DE = tmp;
    
    tmp = RegHL;
    RegHL = Reg_HL;
    Reg_HL = tmp;
    
    return( 1 /* 1 NOP */ );
}


static int ___DA( core_crocods_t *core ) /* JP C, nnnn */
{
    if ( FLAGS & FLAG_C )
    {
        RegPC = PEEK16( core, RegPC );
    }
    else
        RegPC += 2;
    
    return( 3 /* 3 NOPs */ );
}


static int ___DB( core_crocods_t *core ) /* IN A, ( n ) */
{
    RegA = ( UBYTE )ReadPort( core, ( RegA << 8 ) + PEEK8( core, RegPC ) );
    RegPC++;
    return( 3 /* 3 NOPs */ );
}


static int ___DC( core_crocods_t *core ) /* CALL C, nnnn */
{
    if ( FLAGS & FLAG_C )
    {
        RegSP -= 2;
        POKE16( core, RegSP, ( USHORT )( RegPC + 2 ) );
        RegPC = PEEK16( core, RegPC );
        return( 5 /* 5 NOPs */ );
    }
    else
    {
        RegPC += 2;
        return( 3 /* 3 NOPs */ );
    }
}


static int ___DD( core_crocods_t *core ) /* Special code DD : IX */
{
    RegR = ( UBYTE )( ( ( RegR + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ) );
    int r = tabIX[ PEEK8( core, RegPC++ ) ](core);
    return( r );
}


static int ___DE( core_crocods_t *core ) /* SBC A, ee */
{
    SBC_R8( core, PEEK8( core, RegPC ) );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___DF( core_crocods_t *core ) /* RST 18 */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegPC );
    RegPC = 0x18;
    return( 4 /* 4 NOPs */ );
}


static int ___E0( core_crocods_t *core ) /* RET PO */
{
    if ( ! ( FLAGS & FLAG_V ) )
    {
        RegPC = PEEK16( core, RegSP );
        RegSP += 2;
        return( 4 /* 4 NOPs */ );
    }
    else
        return( 2 /* 2 NOPs */ );
}


static int ___E1( core_crocods_t *core ) /* POP HL */
{
    RegHL = PEEK16( core, RegSP );
    RegSP += 2;
    return( 3 /* 3 NOPs */ );
}


static int ___E2( core_crocods_t *core ) /* JP PO, nnnn */
{
    if ( ! ( FLAGS & FLAG_V ) )
    {
        RegPC = PEEK16( core, RegPC );
    }
    else
        RegPC += 2;
    
    return( 3 /* 3 NOPs */ );
}


static int ___E3( core_crocods_t *core ) /* EX (SP), HL */
{
    USHORT a = PEEK16( core, RegSP );
    POKE16( core, RegSP, RegHL );
    RegHL = a;
    return( 6 /* 6 NOPs */ );
}


static int ___E4( core_crocods_t *core ) /* CALL PO, nnnn */
{
    if ( ! ( FLAGS & FLAG_V ) )
    {
        RegSP -= 2;
        POKE16( core, RegSP, ( USHORT )( RegPC + 2 ) );
        RegPC = PEEK16( core, RegPC );
        return( 5 /* 5 NOPs */ );
    }
    else
    {
        RegPC += 2;
        return( 3 /* 3 NOPs */ );
    }
}


static int ___E5( core_crocods_t *core ) /* PUSH HL */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegHL );
    return( 4 /* 4 NOPs */ );
}


static int ___E6( core_crocods_t *core ) /* AND ee */
{
    RegA &= PEEK8( core, RegPC );
    FLAGS = ( UBYTE )( FLAG_H | Parite[ RegA ] );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___E7( core_crocods_t *core ) /* RST 20 */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegPC );
    RegPC = 0x20;
    return( 4 /* 4 NOPs */ );
}


static int ___E8( core_crocods_t *core ) /* RET PE */
{
    if ( FLAGS & FLAG_V )
    {
        RegPC = PEEK16( core, RegSP );
        RegSP += 2;
        return( 4 /* 4 NOPs */ );
    }
    else
        return( 2 /* 2 NOPs */ );
}


static int ___E9( core_crocods_t *core ) /* JP ( HL ) */
{
    RegPC = RegHL;
    return( 1 /* 1 NOP */ );
}


static int ___EA( core_crocods_t *core ) /* JP PE, nnnn */
{
    if ( FLAGS & FLAG_V )
    {
        RegPC = PEEK16( core, RegPC );
    }
    else
        RegPC += 2;
    
    return( 3 /* 3 NOPs */ );
}


static int ___EB( core_crocods_t *core ) /* EX DE, HL */
{
    USHORT tmp = RegDE;
    RegDE = RegHL;
    RegHL = tmp;
    return( 1 /* 1 NOP */ );
}


static int ___EC( core_crocods_t *core ) /* CALL PE, nnnn */
{
    if ( FLAGS & FLAG_V )
    {
        RegSP -= 2;
        POKE16( core, RegSP, ( USHORT )( RegPC + 2 ) );
        RegPC = PEEK16( core, RegPC );
        return( 5 /* 5 NOPs */ );
    }
    else
    {
        RegPC += 2;
        return( 3 /* 3 NOPs */ );
    }
}


static int ___ED( core_crocods_t *core ) /* Special code ED */
{
    RegR = ( UBYTE )( ( ( RegR + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ) );
    
    int r = tabED[ PEEK8( core, RegPC++ ) ](core);
    return( r );
}


static int ___EE( core_crocods_t *core ) /* XOR ee */
{
    RegA ^= PEEK8( core, RegPC );
    FLAGS = Parite[ RegA ];
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___EF( core_crocods_t *core ) /* RST 28 */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegPC );
    RegPC = 0x28;
    return( 4 /* 4 NOPs */ );
}


static int ___F0( core_crocods_t *core ) /* RET P */
{
    if ( ! ( FLAGS & FLAG_S ) )
    {
        RegPC = PEEK16( core, RegSP );
        RegSP += 2;
        return( 4 /* 4 NOPs */ );
    }
    else
        return( 2 /* 2 NOPs */ );
}


static int ___F1( core_crocods_t *core ) /* POP AF */
{
    RegAF = PEEK16( core, RegSP );
    RegSP += 2;
    return( 3 /* 3 NOPs */ );
}


static int ___F2( core_crocods_t *core ) /* JP P, nnnn */
{
    if ( ! ( FLAGS & FLAG_S ) )
    {
        RegPC = PEEK16( core, RegPC );
    }
    else
        RegPC += 2;
    
    return( 3 /* 3 NOPs */ );
}


static int ___F3( core_crocods_t *core ) /* DI */
{
    core->Z80.IFF1 = core->Z80.IFF2 = 0;
    return( 1 /* 1 NOP */ );
}


static int ___F4( core_crocods_t *core ) /* CALL P, nnnn */
{
    if ( ! ( FLAGS & FLAG_S ) )
    {
        RegSP -= 2;
        POKE16( core, RegSP, ( USHORT )( RegPC + 2 ) );
        RegPC = PEEK16( core, RegPC );
        return( 5 /* 5 NOPs */ );
    }
    else
    {
        RegPC += 2;
        return( 3 /* 3 NOPs */ );
    }
}


static int ___F5( core_crocods_t *core ) /* PUSH AF */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegAF );
    return( 4 /* 4 NOPs */ );
}


static int ___F6( core_crocods_t *core ) /* OR ee */
{
    RegA |= PEEK8( core, RegPC );
    FLAGS = Parite[ RegA ];
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___F7( core_crocods_t *core ) /* RST 30 */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegPC );
    RegPC = 0x30;
    return( 4 /* 4 NOPs */ );
}


static int ___F8( core_crocods_t *core ) /* RET M */
{
    if ( FLAGS & FLAG_S )
    {
        RegPC = PEEK16( core, RegSP );
        RegSP += 2;
        return( 4 /* 4 NOPs */ );
    }
    else
        return( 2 /* 2 NOPs */ );
}


static int ___F9( core_crocods_t *core ) /* LD SP, HL */
{
    RegSP = RegHL;
    return( 2 /* 2 NOPs */ );
}


static int ___FA( core_crocods_t *core ) /* JP M, nnnn */
{
    if ( FLAGS & FLAG_S )
    {
        RegPC = PEEK16( core, RegPC );
    }
    else
        RegPC += 2;
    
    return( 3 /* 3 NOPs */ );
}


static int ___FB( core_crocods_t *core ) /* EI */
{
    core->Z80.IFF1 = core->Z80.IFF2 = 1;
#ifdef HACK_IRQ
    VerifyIRQ(core);
#endif
    return( 1 /* 1 NOP */ );
}


static int ___FC( core_crocods_t *core ) /* CALL M, nnnn */
{
    if ( FLAGS & FLAG_S )
    {
        RegSP -= 2;
        POKE16( core, RegSP, ( USHORT )( RegPC + 2 ) );
        RegPC = PEEK16( core, RegPC );
        return( 5 /* 5 NOPs */ );
    }
    else
    {
        RegPC += 2;
        return( 3 /* 3 NOPs */ );
    }
}


static int ___FD( core_crocods_t *core ) /* Special code FD : IY */
{
    RegR = ( UBYTE )( ( ( RegR + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ) );
    int r = tabIY[ PEEK8( core, RegPC++ ) ](core);
    return( r );
}


static int ___FE( core_crocods_t *core ) /* CP ee */
{
    CP_R8( core, PEEK8( core, RegPC ) );
    RegPC++;
    return( 2 /* 2 NOPs */ );
}


static int ___FF( core_crocods_t *core ) /* RST 38 */
{
    RegSP -= 2;
    POKE16( core, RegSP, RegPC );
    RegPC = 0x38;
    return( 4 /* 4 NOPs */ );
}

static pfct tabinstr[ 256 ] =
{
    NO_OP, ___01, ___02, ___03, ___04, ___05, ___06, ___07, // 00
    ___08, ___09, ___0A, ___0B, ___0C, ___0D, ___0E, ___0F, // 08
    ___10, ___11, ___12, ___13, ___14, ___15, ___16, ___17, // 10
    ___18, ___19, ___1A, ___1B, ___1C, ___1D, ___1E, ___1F, // 18
    ___20, ___21, ___22, ___23, ___24, ___25, ___26, ___27, // 20
    ___28, ___29, ___2A, ___2B, ___2C, ___2D, ___2E, ___2F, // 28
    ___30, ___31, ___32, ___33, ___34, ___35, ___36, ___37, // 30
    ___38, ___39, ___3A, ___3B, ___3C, ___3D, ___3E, ___3F, // 38
    NO_OP, ___41, ___42, ___43, ___44, ___45, ___46, ___47, // 40
    ___48, NO_OP, ___4A, ___4B, ___4C, ___4D, ___4E, ___4F, // 48
    ___50, ___51, NO_OP, ___53, ___54, ___55, ___56, ___57, // 50
    ___58, ___59, ___5A, NO_OP, ___5C, ___5D, ___5E, ___5F, // 58
    ___60, ___61, ___62, ___63, NO_OP, ___65, ___66, ___67, // 60
    ___68, ___69, ___6A, ___6B, ___6C, NO_OP, ___6E, ___6F, // 68
    ___70, ___71, ___72, ___73, ___74, ___75, ___76, ___77, // 70
    ___78, ___79, ___7A, ___7B, ___7C, ___7D, ___7E, NO_OP, // 78
    ___80, ___81, ___82, ___83, ___84, ___85, ___86, ___87, // 80
    ___88, ___89, ___8A, ___8B, ___8C, ___8D, ___8E, ___8F, // 88
    ___90, ___91, ___92, ___93, ___94, ___95, ___96, ___97, // 90
    ___98, ___99, ___9A, ___9B, ___9C, ___9D, ___9E, ___9F, // 98
    ___A0, ___A1, ___A2, ___A3, ___A4, ___A5, ___A6, ___A7, // A0
    ___A8, ___A9, ___AA, ___AB, ___AC, ___AD, ___AE, ___AF, // A8
    ___B0, ___B1, ___B2, ___B3, ___B4, ___B5, ___B6, ___B7, // B0
    ___B8, ___B9, ___BA, ___BB, ___BC, ___BD, ___BE, ___BF, // B8
    ___C0, ___C1, ___C2, ___C3, ___C4, ___C5, ___C6, ___C7, // C0
    ___C8, ___C9, ___CA, ___CB, ___CC, ___CD, ___CE, ___CF, // C8
    ___D0, ___D1, ___D2, ___D3, ___D4, ___D5, ___D6, ___D7, // D0
    ___D8, ___D9, ___DA, ___DB, ___DC, ___DD, ___DE, ___DF, // D8
    ___E0, ___E1, ___E2, ___E3, ___E4, ___E5, ___E6, ___E7, // E0
    ___E8, ___E9, ___EA, ___EB, ___EC, ___ED, ___EE, ___EF, // E8
    ___F0, ___F1, ___F2, ___F3, ___F4, ___F5, ___F6, ___F7, // F0
    ___F8, ___F9, ___FA, ___FB, ___FC, ___FD, ___FE, ___FF  // F8
};


pfct tabCB[ 256 ] =
{
    CB_00, CB_01, CB_02, CB_03, CB_04, CB_05, CB_06, CB_07, // 00
    CB_08, CB_09, CB_0A, CB_0B, CB_0C, CB_0D, CB_0E, CB_0F, // 08
    CB_10, CB_11, CB_12, CB_13, CB_14, CB_15, CB_16, CB_17, // 10
    CB_18, CB_19, CB_1A, CB_1B, CB_1C, CB_1D, CB_1E, CB_1F, // 18
    CB_20, CB_21, CB_22, CB_23, CB_24, CB_25, CB_26, CB_27, // 20
    CB_28, CB_29, CB_2A, CB_2B, CB_2C, CB_2D, CB_2E, CB_2F, // 28
    CB_30, CB_31, CB_32, CB_33, CB_34, CB_35, CB_36, CB_37, // 30
    CB_38, CB_39, CB_3A, CB_3B, CB_3C, CB_3D, CB_3E, CB_3F, // 38
    CB_40, CB_41, CB_42, CB_43, CB_44, CB_45, CB_46, CB_47, // 40
    CB_48, CB_49, CB_4A, CB_4B, CB_4C, CB_4D, CB_4E, CB_4F, // 48
    CB_50, CB_51, CB_52, CB_53, CB_54, CB_55, CB_56, CB_57, // 50
    CB_58, CB_59, CB_5A, CB_5B, CB_5C, CB_5D, CB_5E, CB_5F, // 58
    CB_60, CB_61, CB_62, CB_63, CB_64, CB_65, CB_66, CB_67, // 60
    CB_68, CB_69, CB_6A, CB_6B, CB_6C, CB_6D, CB_6E, CB_6F, // 68
    CB_70, CB_71, CB_72, CB_73, CB_74, CB_75, CB_76, CB_77, // 70
    CB_78, CB_79, CB_7A, CB_7B, CB_7C, CB_7D, CB_7E, CB_7F, // 78
    CB_80, CB_81, CB_82, CB_83, CB_84, CB_85, CB_86, CB_87, // 80
    CB_88, CB_89, CB_8A, CB_8B, CB_8C, CB_8D, CB_8E, CB_8F, // 88
    CB_90, CB_91, CB_92, CB_93, CB_94, CB_95, CB_96, CB_97, // 90
    CB_98, CB_99, CB_9A, CB_9B, CB_9C, CB_9D, CB_9E, CB_9F, // 98
    CB_A0, CB_A1, CB_A2, CB_A3, CB_A4, CB_A5, CB_A6, CB_A7, // A0
    CB_A8, CB_A9, CB_AA, CB_AB, CB_AC, CB_AD, CB_AE, CB_AF, // A8
    CB_B0, CB_B1, CB_B2, CB_B3, CB_B4, CB_B5, CB_B6, CB_B7, // B0
    CB_B8, CB_B9, CB_BA, CB_BB, CB_BC, CB_BD, CB_BE, CB_BF, // B8
    CB_C0, CB_C1, CB_C2, CB_C3, CB_C4, CB_C5, CB_C6, CB_C7, // C0
    CB_C8, CB_C9, CB_CA, CB_CB, CB_CC, CB_CD, CB_CE, CB_CF, // C8
    CB_D0, CB_D1, CB_D2, CB_D3, CB_D4, CB_D5, CB_D6, CB_D7, // D0
    CB_D8, CB_D9, CB_DA, CB_DB, CB_DC, CB_DD, CB_DE, CB_DF, // D8
    CB_E0, CB_E1, CB_E2, CB_E3, CB_E4, CB_E5, CB_E6, CB_E7, // E0
    CB_E8, CB_E9, CB_EA, CB_EB, CB_EC, CB_ED, CB_EE, CB_EF, // E8
    CB_F0, CB_F1, CB_F2, CB_F3, CB_F4, CB_F5, CB_F6, CB_F7, // F0
    CB_F8, CB_F9, CB_FA, CB_FB, CB_FC, CB_FD, CB_FE, CB_FF, // F8
};


pfct tabED[ 256 ] =
{
    ED_00, ED_01, ED_02, ED_03, ED_04, ED_05, ED_06, ED_07, // 00
    ED_08, ED_09, ED_0A, ED_0B, ED_0C, ED_0D, ED_0E, ED_0F, // 08
    ED_10, ED_11, ED_12, ED_13, ED_14, ED_15, ED_16, ED_17, // 10
    ED_18, ED_19, ED_1A, ED_1B, ED_1C, ED_1D, ED_1E, ED_1F, // 18
    
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // 20
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // 28
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // 30
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // 38
    ED_40, ED_41, ED_42, ED_43, ED_44, ED_45, ED_46, ED_47, // 40
    ED_48, ED_49, ED_4A, ED_4B, ED_44, ED_4D, ED_46, ED_4F, // 48
    ED_50, ED_51, ED_52, ED_53, ED_44, ED_45, ED_56, ED_57, // 50
    ED_58, ED_59, ED_5A, ED_5B, ED_44, ED_45, ED_5E, ED_5F, // 58
    ED_60, ED_61, ED_62, ED_63, ED_44, ED_45, ED_46, ED_67, // 60
    ED_68, ED_69, ED_6A, ED_6B, ED_44, ED_45, ED_46, ED_6F, // 68
    ED_70, ED_71, ED_72, ED_73, ED_44, ED_45, ED_56, ed___, // 70
    ED_78, ED_79, ED_7A, ED_7B, ED_44, ED_45, ED_5E, ed___, // 78
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // 80
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // 88
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // 90
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // 98
    ED_A0, ED_A1, ED_A2, ED_A3, ed___, ed___, ed___, ed___, // A0
    ED_A8, ED_A9, ED_AA, ED_AB, ed___, ed___, ed___, ed___, // A8
    ED_B0, ED_B1, ED_B2, ED_B3, ed___, ed___, ed___, ed___, // B0
    ED_B8, ED_B9, ED_BA, ED_BB, ed___, ed___, ed___, ed___, // B8
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // C0
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // C8
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // D0
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // D8
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // E0
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // E8
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___, // F0
    ed___, ed___, ed___, ed___, ed___, ed___, ed___, ed___  // F8
};


pfct tabIX[ 256 ] =
{
    NO_OP, ___01, ___02, ___03, ___04, ___05, ___06, ___07, // 00
    ___08, DD_09, ___0A, ___0B, ___0C, ___0D, ___0E, ___0F, // 08
    ___10, ___11, ___12, ___13, ___14, ___15, ___16, ___17, // 10
    ___18, DD_19, ___1A, ___1B, ___1C, ___1D, ___1E, ___1F, // 18
    ___20, DD_21, DD_22, DD_23, DD_24, DD_25, DD_26, ___27, // 20
    ___28, DD_29, DD_2A, DD_2B, DD_2C, DD_2D, DD_2E, ___2F, // 28
    ___30, ___31, ___32, ___33, DD_34, DD_35, DD_36, ___37, // 30
    ___38, DD_39, ___3A, ___3B, ___3C, ___3D, ___3E, ___3F, // 38
    NO_OP, ___41, ___42, ___43, DD_44, DD_45, DD_46, ___47, // 40
    ___48, NO_OP, ___4A, ___4B, DD_4C, DD_4D, DD_4E, ___4F, // 48
    ___50, ___51, NO_OP, ___53, DD_54, DD_55, DD_56, ___57, // 50
    ___58, ___59, ___5A, NO_OP, DD_5C, DD_5D, DD_5E, ___5F, // 58
    DD_60, DD_61, DD_62, DD_63, NO_OP, DD_65, DD_66, DD_67, // 60
    DD_68, DD_69, DD_6A, DD_6B, DD_6C, NO_OP, DD_6E, DD_6F, // 68
    DD_70, DD_71, DD_72, DD_73, DD_74, DD_75, ___76, DD_77, // 70
    ___78, ___79, ___7A, ___7B, DD_7C, DD_7D, DD_7E, NO_OP, // 78
    ___80, ___81, ___82, ___83, DD_84, DD_85, DD_86, ___87, // 80
    ___88, ___89, ___8A, ___8B, DD_8C, DD_8D, DD_8E, ___8F, // 88
    ___90, ___91, ___92, ___93, DD_94, DD_95, DD_96, ___97, // 90
    ___98, ___99, ___9A, ___9B, DD_9C, DD_9D, DD_9E, ___9F, // 98
    ___A0, ___A1, ___A2, ___A3, DD_A4, DD_A5, DD_A6, ___A7, // A0
    ___A8, ___A9, ___AA, ___AB, DD_AC, DD_AD, DD_AE, ___AF, // A8
    ___B0, ___B1, ___B2, ___B3, DD_B4, DD_B5, DD_B6, ___B7, // B0
    ___B8, ___B9, ___BA, ___BB, DD_BC, DD_BD, DD_BE, ___BF, // B8
    ___C0, ___C1, ___C2, ___C3, ___C4, ___C5, ___C6, ___C7, // C0
    ___C8, ___C9, ___CA, DD_CB, ___CC, ___CD, ___CE, ___CF, // C8
    ___D0, ___D1, ___D2, ___D3, ___D4, ___D5, ___D6, ___D7, // D0
    ___D8, ___D9, ___DA, ___DB, ___DC, dd___, ___DE, ___DF, // D8
    ___E0, DD_E1, ___E2, DD_E3, ___E4, DD_E5, ___E6, ___E7, // E0
    ___E8, DD_E9, ___EA, ___EB, ___EC, dd___, ___EE, ___EF, // E8
    ___F0, ___F1, ___F2, ___F3, ___F4, ___F5, ___F6, ___F7, // F0
    ___F8, DD_F9, ___FA, ___FB, ___FC, DD_FD, ___FE, ___FF  // F8
};

pfct tabIY[ 256 ] =
{
    NO_OP, ___01, ___02, ___03, ___04, ___05, ___06, ___07, // 00
    ___08, FD_09, ___0A, ___0B, ___0C, ___0D, ___0E, ___0F, // 08
    ___10, ___11, ___12, ___13, ___14, ___15, ___16, ___17, // 10
    ___18, FD_19, ___1A, ___1B, ___1C, ___1D, ___1E, ___1F, // 18
    ___20, FD_21, FD_22, FD_23, FD_24, FD_25, FD_26, ___27, // 20
    ___28, FD_29, FD_2A, FD_2B, FD_2C, FD_2D, FD_2E, ___2F, // 28
    ___30, ___31, ___32, ___33, FD_34, FD_35, FD_36, ___37, // 30
    ___38, FD_39, ___3A, ___3B, ___3C, ___3D, ___3E, ___3F, // 38
    NO_OP, ___41, ___42, ___43, FD_44, FD_45, FD_46, ___47, // 40
    ___48, NO_OP, ___4A, ___4B, FD_4C, FD_4D, FD_4E, ___4F, // 48
    ___50, ___51, NO_OP, ___53, FD_54, FD_55, FD_56, ___57, // 50
    ___58, ___59, ___5A, NO_OP, FD_5C, FD_5D, FD_5E, ___5F, // 58
    FD_60, FD_61, FD_62, FD_63, NO_OP, FD_65, FD_66, FD_67, // 60
    FD_68, FD_69, FD_6A, FD_6B, FD_6C, NO_OP, FD_6E, FD_6F, // 68
    FD_70, FD_71, FD_72, FD_73, FD_74, FD_75, ___76, FD_77, // 70
    ___78, ___79, ___7A, ___7B, FD_7C, FD_7D, FD_7E, NO_OP, // 78
    ___80, ___81, ___82, ___83, FD_84, FD_85, FD_86, ___87, // 80
    ___88, ___89, ___8A, ___8B, FD_8C, FD_8D, FD_8E, ___8F, // 88
    ___90, ___91, ___92, ___93, FD_94, FD_95, FD_96, ___97, // 90
    ___98, ___99, ___9A, ___9B, FD_9C, FD_9D, FD_9E, ___9F, // 98
    ___A0, ___A1, ___A2, ___A3, FD_A4, FD_A5, FD_A6, ___A7, // A0
    ___A8, ___A9, ___AA, ___AB, FD_AC, FD_AD, FD_AE, ___AF, // A8
    ___B0, ___B1, ___B2, ___B3, FD_B4, FD_B5, FD_B6, ___B7, // B0
    ___B8, ___B9, ___BA, ___BB, FD_BC, FD_BD, FD_BE, ___BF, // B8
    ___C0, ___C1, ___C2, ___C3, ___C4, ___C5, ___C6, ___C7, // C0
    ___C8, ___C9, ___CA, FD_CB, ___CC, ___CD, ___CE, ___CF, // C8
    ___D0, ___D1, ___D2, ___D3, ___D4, ___D5, ___D6, ___D7, // D0
    ___D8, ___D9, ___DA, ___DB, ___DC, FD_DD, ___DE, ___DF, // D8
    ___E0, FD_E1, ___E2, FD_E3, ___E4, FD_E5, ___E6, ___E7, // E0
    ___E8, FD_E9, ___EA, ___EB, ___EC, fd___, ___EE, ___EF, // E8
    ___F0, ___F1, ___F2, ___F3, ___F4, ___F5, ___F6, ___F7, // F0
    ___F8, FD_F9, ___FA, ___FB, ___FC, fd___, ___FE, ___FF  // F8
};


/********************************************************* !NAME! **************
 * Nom : Z80_NMI
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Emulation d'une NMI du Z80
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
int Z80_NMI( core_crocods_t *core )
{
    core->Z80.IFF2 = core->Z80.IFF1;
    core->Z80.IFF1 = 0;
    RegSP -= 2;
    POKE16( core, RegSP, RegPC );
    RegPC = 0x66;
    return( 4 /* 4 NOPs */ );
}

int bycycle;

/********************************************************* !NAME! **************
 * Nom : ExecInstZ80
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Execution de l'instruction Z80 a l'adresse du PC
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80, CntHSync
 *
 ********************************************************** !0! ****************/
int ExecInstZ80_orig(core_crocods_t *core)
{
    bycycle=0;
    
    while(bycycle<core->RegsCRTC[ 0 ] + 1) {
#ifndef HACK_IR
        RegR = ( UBYTE )( ( ( RegR + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ) ); // Retire par RedBug, ca marche sans :)
#endif
        bycycle += tabinstr[ PEEK8( core, RegPC++) ](core);
        
#ifndef HACK_IRQ
        VerifyIRQ(core);
#endif
    }
#ifdef HACK_IR
    RegR = ( UBYTE )( ( ( RegR + core->RegsCRTC[ 0 ] + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ) ); // Fake RegR HACK
#endif
    
    return(bycycle);
}

int ExecInstZ80_debug(core_crocods_t *core)
{
    bycycle=0;
    
    RegR = ( UBYTE )( ( ( RegR + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ) ); // Retire par RedBug, ca marche sans :)
    bycycle += tabinstr[ PEEK8( core, RegPC++) ](core);
    
    VerifyIRQ(core);
    
    return(bycycle);
}

void ExecZ80Code(core_crocods_t *core, char *code, int len, SRegs *result) {
    SRegs oldZ80;
    
    
    //    len=strlen(code);
    
    memcpy(&oldZ80, &core->Z80, sizeof(SRegs));
    
    RegPC = 0;
    memcpy(&core->TabPEEK[0][0], code, len);
    
    
    while(RegPC!=len) {
        bycycle += tabinstr[ PEEK8( core, RegPC++) ](core);
    }
    
    if (result!=NULL) {
        memcpy(result, &core->Z80, sizeof(SRegs));
        
    }
    
    
    memcpy(&core->Z80, &oldZ80, sizeof(SRegs));
    
    
}


/********************************************************* !NAME! **************
 * Nom : ResetZ80
 ********************************************************** !PATHS! *************
 * !./V1!\!./V2!\!./V3!\!./V4!\Fonctions
 ********************************************************** !1! *****************
 *
 * Fichier     : !./FPTH\/FLE!, ligne : !./LN!
 *
 * Description : Reset du Z80
 *
 * Résultat    : /
 *
 * Variables globales modifiées : Z80
 *
 ********************************************************** !0! ****************/
void ResetZ80_orig( core_crocods_t *core )
{
    memset( &core->Z80, 0xFF, sizeof( core->Z80 ) );
    RegPC = 0;
    RegR = core->Z80.IFF1 = core->Z80.IFF2 = core->Z80.InterruptMode = 0;
}



void SetIRQZ80_orig(core_crocods_t *core, int i)
{
    core->IRQ=i;
#ifdef HACK_IRQ
    VerifyIRQ(core);
#endif
}

void VerifyIRQ(core_crocods_t *core) {
    if (core->IRQ) {
#ifdef HACK_IRQ
        if (core->halted) {
            RegPC ++;
            core->halted=0;
        }
#endif
        if ( core->Z80.IFF1 ) // EI ?
        {
            core->Z80.IFF1 = 0;
            RegR = ( UBYTE )( ( ( RegR + 1 ) & 0x7F ) | ( UBYTE )( RegR & 0x80 ));
            core->CntHSync &= 0x1F;
            RegSP -= 2;
            POKE16( core, RegSP, RegPC );
            if ( core->Z80.InterruptMode < 2 ) {
                //
                // IM 0 et IM 1 -> RST 38H
                //
                RegPC = 0x38;
                bycycle += 4;
            } else {
                //
                // IM 2 -> CALL ( adr( IR ) )
                //
                RegPC = PEEK16( core, RegIR );
                bycycle += 4;
            }
            core->IRQ=0;
        }
    }
}

//void WriteZ80(SRegs *z0)
//{
//    Z80.AF.Word = z0->AF.Word;
//    Z80.BC.Word = z0->BC.Word;
//    Z80.DE.Word = z0->DE.Word;
//    Z80.HL.Word = z0->HL.Word;
//    Z80.IR.Word = z0->IR.Word;
//    Z80.IFF1 = z0->IFF1;
//    Z80.IFF2 = z0->IFF2;
//    Z80.IX.Word = z0->IX.Word;
//    Z80.IY.Word = z0->IY.Word;
//    Z80.SP.Word = z0->SP.Word;
//    Z80.PC.Word = z0->PC.Word;
//    Z80.InterruptMode = z0->InterruptMode;
//    Z80._AF.Word = z0->_AF.Word;
//    Z80._BC.Word = z0->_BC.Word;
//    Z80._DE.Word = z0->_DE.Word;
//    Z80._HL.Word = z0->_HL.Word;
//}
//
//void ReadZ80(SRegs *z0)
//{
//    z0->AF.Word = Z80.AF.Word;
//    z0->BC.Word = Z80.BC.Word;
//    z0->DE.Word = Z80.DE.Word;
//    z0->HL.Word = Z80.HL.Word;
//    z0->IR.Word = Z80.IR.Word;
//    z0->IFF1 = Z80.IFF1;
//    z0->IFF2 = Z80.IFF2;
//    z0->IX.Word = Z80.IX.Word;
//    z0->IY.Word = Z80.IY.Word;
//    z0->SP.Word = Z80.SP.Word;
//    z0->PC.Word = Z80.PC.Word;
//    z0->InterruptMode = Z80.InterruptMode;
//    z0->_AF.Word = Z80._AF.Word;
//    z0->_BC.Word = Z80._BC.Word;
//    z0->_DE.Word = Z80._DE.Word;
//    z0->_HL.Word = Z80._HL.Word;
//}
